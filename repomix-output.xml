This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gemini/skills/ai-handler.md
.gemini/skills/mcp-tools.md
.gitignore
.mcp.json
AgentSwarm.psm1
bridge.json
bridge.ps1
Execute-GrandPlan.ps1
gemini-mcp-config.json
gemini.bat
GEMINI.md
gemini.ps1
GeminiGUI/.gitignore
GeminiGUI/index.html
GeminiGUI/package.json
GeminiGUI/public/background.webp
GeminiGUI/public/backgroundlight.webp
GeminiGUI/public/icon.ico
GeminiGUI/public/logo.webp
GeminiGUI/public/logodark.webp
GeminiGUI/public/logolight.webp
GeminiGUI/public/tauri.svg
GeminiGUI/public/vite.svg
GeminiGUI/README.md
GeminiGUI/src-tauri/.gitignore
GeminiGUI/src-tauri/build.rs
GeminiGUI/src-tauri/capabilities/default.json
GeminiGUI/src-tauri/Cargo.toml
GeminiGUI/src-tauri/icons/128x128.png
GeminiGUI/src-tauri/icons/128x128@2x.png
GeminiGUI/src-tauri/icons/32x32.png
GeminiGUI/src-tauri/icons/icon.icns
GeminiGUI/src-tauri/icons/icon.ico
GeminiGUI/src-tauri/icons/icon.png
GeminiGUI/src-tauri/icons/Square107x107Logo.png
GeminiGUI/src-tauri/icons/Square142x142Logo.png
GeminiGUI/src-tauri/icons/Square150x150Logo.png
GeminiGUI/src-tauri/icons/Square284x284Logo.png
GeminiGUI/src-tauri/icons/Square30x30Logo.png
GeminiGUI/src-tauri/icons/Square310x310Logo.png
GeminiGUI/src-tauri/icons/Square44x44Logo.png
GeminiGUI/src-tauri/icons/Square71x71Logo.png
GeminiGUI/src-tauri/icons/Square89x89Logo.png
GeminiGUI/src-tauri/icons/StoreLogo.png
GeminiGUI/src-tauri/src/lib.rs
GeminiGUI/src-tauri/src/main.rs
GeminiGUI/src-tauri/tauri.conf.json
GeminiGUI/src/App.css
GeminiGUI/src/App.tsx
GeminiGUI/src/assets/react.svg
GeminiGUI/src/components/BridgePanel.tsx
GeminiGUI/src/components/ChatContainer.tsx
GeminiGUI/src/components/CodeBlock.tsx
GeminiGUI/src/components/MemoryPanel.tsx
GeminiGUI/src/components/RightSidebar.tsx
GeminiGUI/src/components/SessionSidebar.tsx
GeminiGUI/src/components/SettingsModal.tsx
GeminiGUI/src/components/StatusFooter.tsx
GeminiGUI/src/main.tsx
GeminiGUI/src/store/useAppStore.ts
GeminiGUI/src/vite-env.d.ts
GeminiGUI/src/workers/heavyLogic.worker.ts
GeminiGUI/tsconfig.json
GeminiGUI/tsconfig.node.json
GeminiGUI/vite.config.ts
Generate-MCP-Config.ps1
grimoires/browser_tools.md
grimoires/filesystem_tools.md
grimoires/git_tools.md
icon.ico
launch-gui.bat
mcp/package.json
package.json
public/background.webp
public/backgroundlight.webp
public/icon.ico
public/logo.webp
public/logodark.webp
public/logolight.webp
run-portable-gemini.ps1
setup-mcp.ps1
setup-ollama.ps1
src/logger/colors.js
src/logger/index.js
src/tools/base-tool.js
src/tools/errors.js
src/tools/index.js
start-ollama.ps1
Test-Dijkstra.ps1
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gemini/skills/ai-handler.md">
# AI Handler Skills for GeminiCLI

## /ai - Quick Local AI Query

Execute a quick query to local Ollama model.

**Usage:**
```
/ai <prompt>
```

**Examples:**
```
/ai "Write a function to check if a number is prime"
/ai "Explain the difference between let and const in JavaScript"
```

**Implementation:**
```bash
powershell -ExecutionPolicy Bypass -Command "& { $response = ollama run qwen2.5-coder:1.5b '$ARGS'; Write-Host $response }"
```

---

## /ai-batch - Parallel Batch AI Queries

Process multiple prompts in parallel using Ollama.

**Usage:**
```
/ai-batch <prompts-file.txt>
```

**File format:**
```
Prompt 1
Prompt 2
Prompt 3
```

**Implementation:**
```bash
powershell -ExecutionPolicy Bypass -File "C:\Users\BIURODOM\Desktop\GeminiCLI\scripts\ai-batch.ps1" "$ARGS"
```

---

## /ai-pull - Pull Ollama Model

Download a new model to Ollama.

**Usage:**
```
/ai-pull <model-name>
```

**Popular models:**
- `llama3.2:1b` - Fast, small (1.3GB)
- `llama3.2:3b` - Balanced (2GB)
- `llama3.2:7b` - Large, accurate (4GB)
- `qwen2.5-coder:1.5b` - Best for code (1GB)
- `qwen2.5-coder:7b` - Better for code (4GB)
- `phi3:mini` - Microsoft, good general (2.2GB)
- `gemma2:2b` - Google's model (1.6GB)
- `codellama:7b` - Meta, for code (4GB)

**Implementation:**
```bash
ollama pull "$ARGS"
```

---

## /ai-status - Check AI Status

Check AI providers status (Ollama, models, configuration).

**Usage:**
```
/ai-status
```

**Implementation:**
```bash
ollama list && curl -s http://127.0.0.1:11434/api/tags | jq '.models[] | {name, size}'
```

---

## /ai-models - List Available Models

List all locally installed Ollama models.

**Usage:**
```
/ai-models
```

**Implementation:**
```bash
ollama list
```

---

## /swarm - Run Agent Swarm

Execute a task using the Witcher-themed AI agent swarm.

**Usage:**
```
/swarm <task-description>
```

**Available agents:**
- **Geralt** - Security/VETO (llama3.2:3b)
- **Yennefer** - Design patterns (qwen2.5-coder:1.5b)
- **Triss** - QA/Testing (qwen2.5-coder:1.5b)
- **Jaskier** - User summaries (llama3.2:3b)
- **Vesemir** - Plan reviewer (llama3.2:3b)
- **Ciri** - Fast executor (llama3.2:1b)
- **Dijkstra** - Master strategist (gemini)

**Implementation:**
```powershell
Import-Module "C:\Users\BIURODOM\Desktop\GeminiCLI\AgentSwarm.psm1"
Invoke-SwarmTask -Task "$ARGS"
```

---

## /memory - Manage Agent Memory

Interact with the agent memory system.

**Usage:**
```
/memory add <key> <value>    # Add memory entry
/memory get <key>            # Get memory entry
/memory list                 # List all memories
/memory search <query>       # Search memories
```

**Implementation:**
```powershell
Import-Module "C:\Users\BIURODOM\Desktop\GeminiCLI\AgentSwarm.psm1"
# Memory operations
```

---

## /mcp - MCP Server Management

Manage Model Context Protocol servers.

**Usage:**
```
/mcp list                    # List all MCP servers
/mcp status <server>         # Check server status
/mcp restart <server>        # Restart a server
```

**Available MCP Servers:**
- `ollama` - Local LLM
- `filesystem` - File access
- `memory` - Long-term memory
- `playwright` - Browser automation
- `github` - GitHub API
- `greptile` - Code intelligence
- ... and 18 more!

---

## Configuration

Skills are defined in `.gemini/skills/` directory.

Each skill file should contain:
1. Skill name and description
2. Usage examples
3. Implementation (bash/powershell command)

To add a new skill, create a new `.md` file in the skills directory.
</file>

<file path=".gemini/skills/mcp-tools.md">
# MCP Tools Skills

## Available MCP Servers (24 total)

### Local Servers (stdio/npx) - 15

| Server | Command | Description |
|--------|---------|-------------|
| `ollama` | `npx ollama-mcp` | Local LLM inference |
| `desktop-commander` | `npx @wonderwhy-er/desktop-commander` | Terminal + files + processes |
| `filesystem` | `npx @modelcontextprotocol/server-filesystem` | File system access |
| `memory` | `npx @modelcontextprotocol/server-memory` | Long-term memory |
| `fetch` | `npx @modelcontextprotocol/server-fetch` | HTTP fetch |
| `brave-search` | `npx @anthropic-ai/mcp-server-brave` | Brave search |
| `puppeteer` | `npx @anthropic-ai/mcp-server-puppeteer` | Headless browser |
| `sequential-thinking` | `npx @modelcontextprotocol/server-sequential-thinking` | Chain-of-thought |
| `everything-search` | `npx @anthropic-ai/mcp-server-everything` | Windows Everything |
| `time` | `npx @modelcontextprotocol/server-time` | Time operations |
| `git` | `npx @anthropic-ai/mcp-server-git` | Git operations |
| `context7` | `npx @upstash/context7-mcp` | Library documentation |
| `firebase` | `npx firebase-tools@latest mcp` | Google Firebase |
| `playwright` | `npx @playwright/mcp@latest` | Browser automation |
| `serena` | `uvx serena start-mcp-server` | Symbolic code analysis (LSP) |

### HTTP Servers (remote API) - 6

| Server | URL | Description |
|--------|-----|-------------|
| `github` | `https://api.githubcopilot.com/mcp/` | GitHub Copilot API |
| `gitlab` | `https://gitlab.com/api/v4/mcp` | GitLab API |
| `greptile` | `https://api.greptile.com/mcp` | Code intelligence |
| `linear` | `https://mcp.linear.app/mcp` | Linear issue tracking |
| `stripe` | `https://mcp.stripe.com` | Stripe payments |
| `supabase` | `https://mcp.supabase.com/mcp` | Supabase backend |

### SSE Servers (Server-Sent Events) - 2

| Server | URL | Description |
|--------|-----|-------------|
| `asana` | `https://mcp.asana.com/sse` | Asana tasks |
| `slack` | `https://mcp.slack.com/sse` | Slack messaging |

---

## /mcp-list - List MCP Servers

**Usage:**
```
/mcp-list
```

**Implementation:**
```bash
cat "C:\Users\BIURODOM\Desktop\GeminiCLI\.mcp.json" | jq '.mcpServers | keys[]'
```

---

## /mcp-test - Test MCP Server

**Usage:**
```
/mcp-test <server-name>
```

**Implementation:**
```bash
# For local servers
npx <server-package> --help

# For HTTP servers
curl -I <server-url>
```

---

## Environment Variables Required

```env
# For brave-search
BRAVE_API_KEY=your_brave_api_key

# For github
GITHUB_PERSONAL_ACCESS_TOKEN=your_github_token

# For greptile
GREPTILE_API_KEY=your_greptile_key
```

Create a `.env` file in the GeminiCLI directory with these values.
</file>

<file path=".mcp.json">
{
  "mcpServers": {
    "ollama": {
      "command": "cmd",
      "args": ["/c", "npx", "-y", "ollama-mcp"],
      "env": {
        "OLLAMA_HOST": "http://127.0.0.1:11434"
      }
    },
    "desktop-commander": {
      "command": "cmd",
      "args": ["/c", "npx", "-y", "@wonderwhy-er/desktop-commander"]
    },
    "filesystem": {
      "command": "cmd",
      "args": [
        "/c", "npx", "-y",
        "@modelcontextprotocol/server-filesystem",
        "C:/Users/BIURODOM/Desktop",
        "C:/Users/BIURODOM/Documents",
        "C:/Users/BIURODOM/Downloads"
      ]
    },
    "memory": {
      "command": "cmd",
      "args": ["/c", "npx", "-y", "@modelcontextprotocol/server-memory"]
    },
    "fetch": {
      "command": "cmd",
      "args": ["/c", "npx", "-y", "@modelcontextprotocol/server-fetch"]
    },
    "brave-search": {
      "command": "cmd",
      "args": ["/c", "npx", "-y", "@anthropic-ai/mcp-server-brave"],
      "env": {
        "BRAVE_API_KEY": "${BRAVE_API_KEY}"
      }
    },
    "puppeteer": {
      "command": "cmd",
      "args": ["/c", "npx", "-y", "@anthropic-ai/mcp-server-puppeteer"]
    },
    "sequential-thinking": {
      "command": "cmd",
      "args": ["/c", "npx", "-y", "@modelcontextprotocol/server-sequential-thinking"]
    },
    "everything-search": {
      "command": "cmd",
      "args": ["/c", "npx", "-y", "@anthropic-ai/mcp-server-everything"],
      "env": {
        "EVERYTHING_PATH": "C:/Program Files/Everything/Everything.exe"
      }
    },
    "time": {
      "command": "cmd",
      "args": ["/c", "npx", "-y", "@modelcontextprotocol/server-time"]
    },
    "git": {
      "command": "cmd",
      "args": ["/c", "npx", "-y", "@anthropic-ai/mcp-server-git"],
      "env": {
        "GIT_DEFAULT_PATH": "C:/Users/BIURODOM/Desktop/GeminiCLI"
      }
    },
    "context7": {
      "command": "cmd",
      "args": ["/c", "npx", "-y", "@upstash/context7-mcp"]
    },
    "firebase": {
      "command": "cmd",
      "args": ["/c", "npx", "-y", "firebase-tools@latest", "mcp"]
    },
    "playwright": {
      "command": "cmd",
      "args": ["/c", "npx", "-y", "@playwright/mcp@latest"]
    },
    "serena": {
      "command": "cmd",
      "args": ["/c", "uvx", "--from", "git+https://github.com/oraios/serena", "serena", "start-mcp-server"]
    },
    "github": {
      "type": "http",
      "url": "https://api.githubcopilot.com/mcp/",
      "headers": {
        "Authorization": "Bearer ${GITHUB_PERSONAL_ACCESS_TOKEN}"
      }
    },
    "gitlab": {
      "type": "http",
      "url": "https://gitlab.com/api/v4/mcp"
    },
    "greptile": {
      "type": "http",
      "url": "https://api.greptile.com/mcp",
      "headers": {
        "Authorization": "Bearer ${GREPTILE_API_KEY}"
      }
    },
    "linear": {
      "type": "http",
      "url": "https://mcp.linear.app/mcp"
    },
    "stripe": {
      "type": "http",
      "url": "https://mcp.stripe.com"
    },
    "supabase": {
      "type": "http",
      "url": "https://mcp.supabase.com/mcp"
    },
    "asana": {
      "type": "sse",
      "url": "https://mcp.asana.com/sse"
    },
    "slack": {
      "type": "sse",
      "url": "https://mcp.slack.com/sse"
    }
  }
}
</file>

<file path="Execute-GrandPlan.ps1">
<#
.SYNOPSIS
    THE GRAND PLAN ORCHESTRATOR
    Executes 50 tasks across 5 blocks using AgentSwarm v8.3
#>

$ScriptDir = $PSScriptRoot
Import-Module "$ScriptDir\AgentSwarm.psm1" -Force

$Global:PromptPrefix = "**ULTIMATE DIRECTIVE:** You are executing a Grand Plan. 
1. GENERATE REAL, PRODUCTION-READY CODE. NO PLACEHOLDERS. NO '// code goes here'.
2. If modifying a file, READ it first, then WRITE the full updated content.
3. If creating a file, ensure directories exist.
4. Use 'filesystem' tools to persist your work.
"

$Blocks = @(
    @{
        Name = "BLOK 1: KAER MORHEN (Audit)"
        Objective = "Execute BLOCK 1 - Audit & Structure:
        1. Ciri: Map 'src-tauri' and 'GeminiGUI/src' structure (depth 3) to 'tree.txt'.
        2. Geralt: Scan all .ps1/.rs files for hardcoded secrets. Report to 'security_audit.md'.
        3. Yennefer: Analyze 'GeminiGUI/src/App.tsx' complexity. Write report to 'architecture_audit.md'.
        4. Eskel: Check 'package.json' in GeminiGUI/mcp for outdated deps. Write 'deps_report.md'.
        5. Zoltan: Validate syntax of all .json files. Fix if broken.
        6. Triss: Find all tests (.test.ts, .spec.ts). List coverage gaps in 'qa_report.md'.
        7. Lambert: Grep for TODO/FIXME/HACK. Save list to 'technical_debt.md'.
        8. Regis: Compare HYDRA.md vs actual files. Write discrepancies to 'documentation_gap.md'.
        9. Philippa: Identify all fetch/axios calls in React. Map to 'api_map.md'.
        10. Jaskier: Review variable naming in 'lib.rs'. Write roast/report to 'code_style.md'."
    },
    @{
        Name = "BLOK 2: ARETUZA (Documentation)"
        Objective = "Execute BLOCK 2 - Knowledge:
        11. Jaskier: Generate 'CONTRIBUTING.md' with bug report & style guide rules.
        12. Regis: Create Markdown map of Agents <-> MCP Tools usage. Save to 'AGENTS.md'.
        13. Yennefer: Document Tauri<->React Bridge pattern from 'lib.rs'/'useAppStore.ts' to 'ARCHITECTURE.md'.
        14. Philippa: Generate 'OPENAPI_MOCK.yml' based on mcpServers in .mcp.json.
        15. Geralt: Create 'SECURITY.md' defining allowed commands policy from lib.rs.
        16. Ciri: Update '.gitignore' to exclude .log, tmp, cache, .serena.
        17. Eskel: Write 'TROUBLESHOOTING.md' for common Windows build errors.
        18. Vesemir: Analyze AgentSwarm.psm1 and create flow diagram (Mermaid) in 'SWARM_FLOW.md'.
        19. Zoltan: Document Vector DB JSONL schema in 'DATA_SCHEMA.md'.
        20. Triss: Create 'SMOKE_TESTS.md' checklist for manual GUI testing."
    },
    @{
        Name = "BLOK 3: MAHAKAM (Refactor)"
        Objective = "Execute BLOCK 3 - Code Hardening:
        21. Yennefer: Create 'GeminiGUI/src/hooks/useFileDrop.ts'. Extract drag-n-drop logic from ChatContainer.
        22. Lambert: In 'src-tauri/src/lib.rs', wrap read_file in Result matching for better error messages.
        23. Eskel: Create 'src-tauri/build.rs' optimized for caching if missing.
        24. Zoltan: Read .mcp.json, format with 2-space indent, save back.
        25. Philippa: Create 'GeminiGUI/src/services/ollamaService.ts'. Move fetch logic from store there.
        26. Geralt: Modify 'main.rs' to log blocked commands to 'security.log' (simulate code).
        27. Ciri: List 'GeminiGUI/public'. If file not referenced in src, move to 'unused/'.
        28. Triss: Create 'src/tools/tools.test.js' with 3 simple unit tests for base-tool.js.
        29. Regis: Create 'GeminiGUI/src/types/tauri.d.ts' based on rust commands.
        30. Dijkstra: Organize '.gemini' folder. Create 'logs' and 'tmp' subfolders if missing."
    },
    @{
        Name = "BLOK 4: BROKILON (Features)"
        Objective = "Execute BLOCK 4 - New Capabilities:
        31. Philippa: Create 'GeminiGUI/src/components/ToolConnector.tsx' (mock UI) for toggling MCP servers.
        32. Yennefer: Create 'GeminiGUI/src/components/ThinkingIndicator.tsx' (Framer Motion component).
        33. Zoltan: Create 'GeminiGUI/src/utils/exportChat.ts' (function to download JSON/MD).
        34. Geralt: Create 'GeminiGUI/src/components/PanicButton.tsx' (Red button UI).
        35. Lambert: Create 'GeminiGUI/src/utils/logger.ts' with verbose debug mode.
        36. Regis: Create 'GeminiGUI/src/hooks/usePromptTemplates.ts' (save/load snippets).
        37. Ciri: Create 'GeminiGUI/src/hooks/useKeyboardShortcuts.ts' (Ctrl+K implementation).
        38. Eskel: Create 'update-hydra.ps1' that does 'git pull' and 'npm run build'.
        39. Triss: Create 'GeminiGUI/src/utils/validators.ts' for API keys.
        40. Vesemir: Create 'presets.json' with 'Dev Mode' and 'Writer Mode' configurations."
    },
    @{
        Name = "BLOK 5: WIELKI LOW (Analysis)"
        Objective = "Execute BLOCK 5 - Stress Testing:
        41. Triss: Create 'tests/load_test_ollama.ps1' measuring 50 requests time.
        42. Ciri: Create 'tests/io_benchmark.ps1' creating/deleting 1000 files.
        43. Lambert: Create 'tests/network_chaos.js' simulating connection drops.
        44. Geralt: Create 'tests/penetration_test.ps1' trying injection attacks.
        45. Zoltan: Create 'tests/memory_leak_check.js' node script (mock).
        46. Yennefer: Create 'GeminiGUI/src/utils/profiler.ts' for React rendering.
        47. Eskel: Create 'measure-startup.ps1' using Get-Process.
        48. Regis: Create 'analyze_sentiment.js' placeholder for chat history.
        49. Philippa: Create 'tests/api_rate_limit_check.ts'.
        50. Dijkstra: Write summary report 'FINAL_MISSION_REPORT.md'."
    }
)

Write-Host "=== INITIATING THE GRAND PLAN (50 TASKS) ===" -ForegroundColor Magenta

foreach ($block in $Blocks) {
    Write-Host "`n>>> STARTING $($block.Name) <<<" -ForegroundColor Cyan
    Write-Host "Objective: $($block.Objective)" -ForegroundColor DarkGray
    
    # Invoke AgentSwarm with YOLO mode for speed
    Invoke-AgentSwarm -Objective $block.Objective -Yolo
    
    Write-Host ">>> COMPLETED $($block.Name) <<<" -ForegroundColor Green
    Start-Sleep -Seconds 2
}

Write-Host "`n=== GRAND PLAN EXECUTED ===" -ForegroundColor Magenta
</file>

<file path="gemini-mcp-config.json">
{
    "mcpServers":  {
                       "git":  {
                                   "command":  "cmd",
                                   "args":  [
                                                "/c",
                                                "npx",
                                                "-y",
                                                "@anthropic-ai/mcp-server-git"
                                            ],
                                   "env":  {
                                               "GIT_DEFAULT_PATH":  "C:/Users/BIURODOM/Desktop/GeminiCLI"
                                           }
                               },
                       "gitlab":  {
                                      "type":  "http",
                                      "url":  "https://gitlab.com/api/v4/mcp"
                                  },
                       "everything-search":  {
                                                 "command":  "cmd",
                                                 "args":  [
                                                              "/c",
                                                              "npx",
                                                              "-y",
                                                              "@anthropic-ai/mcp-server-everything"
                                                          ],
                                                 "env":  {
                                                             "EVERYTHING_PATH":  "C:/Program Files/Everything/Everything.exe"
                                                         }
                                             },
                       "time":  {
                                    "command":  "cmd",
                                    "args":  [
                                                 "/c",
                                                 "npx",
                                                 "-y",
                                                 "@modelcontextprotocol/server-time"
                                             ]
                                },
                       "memory":  {
                                      "command":  "C:\\Program Files\\nodejs\\node.exe",
                                      "args":  [
                                                   "C:\\Users\\BIURODOM\\Desktop\\GeminiCLI\\mcp\\node_modules\\@modelcontextprotocol\\server-memory\\dist\\index.js"
                                               ]
                                  },
                       "asana":  {
                                     "type":  "sse",
                                     "url":  "https://mcp.asana.com/sse"
                                 },
                       "filesystem":  {
                                          "command":  "C:\\Program Files\\nodejs\\node.exe",
                                          "args":  [
                                                       "C:\\Users\\BIURODOM\\Desktop\\GeminiCLI\\mcp\\node_modules\\@modelcontextprotocol\\server-filesystem\\dist\\index.js",
                                                       "C:/Users/BIURODOM/Desktop",
                                                       "C:/Users/BIURODOM/Documents",
                                                       "C:/Users/BIURODOM/Downloads"
                                                   ]
                                      },
                       "puppeteer":  {
                                         "command":  "cmd",
                                         "args":  [
                                                      "/c",
                                                      "npx",
                                                      "-y",
                                                      "@anthropic-ai/mcp-server-puppeteer"
                                                  ]
                                     },
                       "slack":  {
                                     "type":  "sse",
                                     "url":  "https://mcp.slack.com/sse"
                                 },
                       "stripe":  {
                                      "type":  "http",
                                      "url":  "https://mcp.stripe.com"
                                  },
                       "desktop-commander":  {
                                                 "command":  "cmd",
                                                 "args":  [
                                                              "/c",
                                                              "npx",
                                                              "-y",
                                                              "@wonderwhy-er/desktop-commander"
                                                          ]
                                             },
                       "brave-search":  {
                                            "command":  "cmd",
                                            "args":  [
                                                         "/c",
                                                         "npx",
                                                         "-y",
                                                         "@anthropic-ai/mcp-server-brave"
                                                     ],
                                            "env":  {
                                                        "BRAVE_API_KEY":  "BSAXJ2S-GwXLGx8yHnaMJ2cX1w51DRi"
                                                    }
                                        },
                       "fetch":  {
                                     "command":  "cmd",
                                     "args":  [
                                                  "/c",
                                                  "npx",
                                                  "-y",
                                                  "@modelcontextprotocol/server-fetch"
                                              ]
                                 },
                       "ollama":  {
                                      "command":  "cmd",
                                      "args":  [
                                                   "/c",
                                                   "npx",
                                                   "-y",
                                                   "ollama-mcp"
                                               ],
                                      "env":  {
                                                  "OLLAMA_HOST":  "http://127.0.0.1:11434"
                                              }
                                  },
                       "github":  {
                                      "type":  "http",
                                      "url":  "https://api.githubcopilot.com/mcp/",
                                      "headers":  {
                                                      "Authorization":  "Bearer ${GITHUB_PERSONAL_ACCESS_TOKEN}"
                                                  }
                                  },
                       "context7":  {
                                        "command":  "cmd",
                                        "args":  [
                                                     "/c",
                                                     "npx",
                                                     "-y",
                                                     "@upstash/context7-mcp"
                                                 ]
                                    },
                       "serena":  {
                                      "command":  "cmd",
                                      "args":  [
                                                   "/c",
                                                   "uvx",
                                                   "--from",
                                                   "git+https://github.com/oraios/serena",
                                                   "serena",
                                                   "start-mcp-server"
                                               ]
                                  },
                       "firebase":  {
                                        "command":  "cmd",
                                        "args":  [
                                                     "/c",
                                                     "npx",
                                                     "-y",
                                                     "firebase-tools@latest",
                                                     "mcp"
                                                 ]
                                    },
                       "greptile":  {
                                        "type":  "http",
                                        "url":  "https://api.greptile.com/mcp",
                                        "headers":  {
                                                        "Authorization":  "Bearer ${GREPTILE_API_KEY}"
                                                    }
                                    },
                       "sequential-thinking":  {
                                                   "command":  "cmd",
                                                   "args":  [
                                                                "/c",
                                                                "npx",
                                                                "-y",
                                                                "@modelcontextprotocol/server-sequential-thinking"
                                                            ]
                                               },
                       "linear":  {
                                      "type":  "http",
                                      "url":  "https://mcp.linear.app/mcp"
                                  },
                       "playwright":  {
                                          "command":  "cmd",
                                          "args":  [
                                                       "/c",
                                                       "npx",
                                                       "-y",
                                                       "@playwright/mcp@latest"
                                                   ]
                                      },
                       "supabase":  {
                                        "type":  "http",
                                        "url":  "https://mcp.supabase.com/mcp"
                                    }
                   }
}
</file>

<file path="GEMINI.md">
# GeminiCLI - Instrukcje i Konfiguracja

## Tryb pracy

Ta instalacja GeminiCLI działa w trybie **portable** z pełnym dostępem do narzędzi MCP.

**Wersja:** 0.2.0 (po refaktorze bezpieczeństwa)

---

## Architektura GUI (po refaktorze)

### Komponenty React

```
src/
├── App.tsx                    # Koordynator (~310 linii)
├── components/
│   ├── ChatContainer.tsx      # Wiadomości + Input + Drag&Drop
│   ├── SessionSidebar.tsx     # Lista sesji + wyszukiwanie
│   ├── RightSidebar.tsx       # Memory + Bridge + Workers
│   ├── StatusFooter.tsx       # Status line + zegar
│   ├── MemoryPanel.tsx        # System pamięci agentów
│   ├── BridgePanel.tsx        # CLI Bridge (React Query)
│   ├── CodeBlock.tsx          # Blok kodu z Run/Save/Copy
│   └── SettingsModal.tsx      # Ustawienia
└── store/
    └── useAppStore.ts         # Zustand z walidacją
```

### Backend Rust (lib.rs)

**Komendy Tauri:**
- `get_bridge_state`, `set_auto_approve`, `approve_request`, `reject_request`
- `get_ollama_models`, `get_gemini_models`, `get_gemini_models_sorted`
- `prompt_ollama`, `prompt_ollama_stream`, `prompt_gemini_stream`
- `run_system_command` (z allowlist!)
- `spawn_swarm_agent` (z walidacją)
- `save_file_content` (z path validation)
- `get_env_vars`, `start_ollama_server`

**System Pamięci:**
- `get_agent_memories`, `add_agent_memory`, `clear_agent_memories`
- `get_knowledge_graph`, `add_knowledge_node`, `add_knowledge_edge`

---

## Zabezpieczenia (KRYTYCZNE)

### 1. Command Injection Prevention (lib.rs)

```rust
const ALLOWED_COMMANDS: &[&str] = &[
    "dir", "ls", "pwd", "echo", "type", "cat",
    "git status", "git log", "git branch",
    "ollama list", "ollama ps",
    "node --version", "python --version",
];
```

### 2. Shell Escaping (CodeBlock.tsx)

```typescript
const escapeForShell = (code: string): string => {
    return code
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/`/g, '\\`')
        .replace(/\$/g, '\\$');
};
```

### 3. Path Validation (lib.rs)

- Blokowane: `C:\Windows`, `C:\Program Files`, `/etc`, `/usr`
- Blokowane rozszerzenia: `.exe`, `.bat`, `.ps1`, `.sh`, `.dll`

### 4. Store Validation (useAppStore.ts)

- URL validation dla `ollamaEndpoint`
- API key format check dla `geminiApiKey`
- Content length limits (50KB messages, 10KB system prompt)
- Max 100 sesji, 1000 wiadomości per sesja

---

## MCP Servers (24 serwery)

### Local (stdio/npx) - 15

| Serwer | Opis |
|--------|------|
| `ollama` | Local LLM inference |
| `desktop-commander` | Terminal + pliki |
| `filesystem` | Dostęp do plików |
| `memory` | Pamięć długoterminowa |
| `playwright` | Browser automation |
| `serena` | Symbolic code analysis (LSP) |
| `context7` | Library documentation |
| `firebase` | Google Firebase |
| ... | i więcej |

### HTTP - 6

| Serwer | URL |
|--------|-----|
| `github` | `https://api.githubcopilot.com/mcp/` |
| `greptile` | `https://api.greptile.com/mcp` |
| `linear` | `https://mcp.linear.app/mcp` |
| ... | i więcej |

### SSE - 2

| Serwer | URL |
|--------|-----|
| `asana` | `https://mcp.asana.com/sse` |
| `slack` | `https://mcp.slack.com/sse` |

---

## Agent Swarm (12 agentów)

| Agent | Model | Rola |
|-------|-------|------|
| **Geralt** | llama3.2:3b | Security/VETO |
| **Yennefer** | qwen2.5-coder:1.5b | Design patterns |
| **Triss** | qwen2.5-coder:1.5b | QA/Testing |
| **Jaskier** | llama3.2:3b | User summaries |
| **Vesemir** | llama3.2:3b | Plan reviewer |
| **Ciri** | llama3.2:1b | Fast executor |
| **Eskel** | llama3.2:3b | DevOps/Build |
| **Lambert** | qwen2.5-coder:1.5b | Debugger |
| **Zoltan** | llama3.2:3b | Data master |
| **Regis** | phi3:mini | Researcher |
| **Dijkstra** | gemini:dynamic | Master strategist |
| **Philippa** | qwen2.5-coder:1.5b | API specialist |

---

## Uruchomienie

### CLI
```powershell
.\gemini.ps1
```

### GUI (Development)
```powershell
cd GeminiGUI
npm install
npm run tauri dev
```

### GUI (Production Build)
```powershell
cd GeminiGUI
npm run tauri build
```

---

## Wymagania

- Node.js 20+
- Rust 1.75+
- PowerShell 7+
- Ollama (zainstalowany w bin/ lub systemowo)

---

## Changelog

### v0.2.0 (Refaktor bezpieczeństwa)

**SECURITY:**
- [x] Command injection fix - allowlist w `run_system_command()`
- [x] Shell injection fix - bezpieczne przekazywanie args w `spawn_swarm_agent()`
- [x] Quote injection fix - `escapeForShell()` w CodeBlock.tsx
- [x] Path traversal fix - walidacja ścieżek w `save_file_content()`
- [x] Portable paths - dynamiczne `get_base_dir()` zamiast hardcoded

**ARCHITECTURE:**
- [x] App.tsx split: 720 → 310 linii
- [x] Nowe komponenty: ChatContainer, SessionSidebar, RightSidebar, StatusFooter
- [x] MemoryPanel - pełna implementacja z Tauri commands
- [x] BridgePanel - React Query z adaptive polling

**QUALITY:**
- [x] useAppStore - walidacja URL, API key, limity
- [x] Locked versions - package.json + Cargo.toml
- [x] Release profile - LTO, strip, opt-level 3

### v0.1.0 (Migracja z ClaudeCli)

- [x] 24 MCP servers
- [x] Logger strukturalny
- [x] Tool Registry z Zod
- [x] Skills System

---

## Notatki bezpieczeństwa

- Klucze API przechowuj w `.env` (NIGDY w repo!)
- `.mcp.json` używa placeholderów `${VAR_NAME}`
- Logi są rotowane i usuwane po 7 dniach
- Pamięć agentów limitowana do 1000 wpisów
</file>

<file path="GeminiGUI/src/components/ChatContainer.tsx">
import { useState, useRef } from 'react';
import { motion } from 'framer-motion';
import { Send, RefreshCw, FileText, Terminal, X, Paperclip } from 'lucide-react';
import { Virtuoso, VirtuosoHandle } from 'react-virtuoso';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { CodeBlock } from './CodeBlock';

interface Message {
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
}

interface ChatContainerProps {
  messages: Message[];
  isStreaming: boolean;
  modelsLoading: boolean;
  modelsError: unknown;
  models: string[] | undefined;
  selectedModel: string;
  onSelectModel: (model: string) => void;
  onSubmit: (prompt: string, image: string | null) => void;
  onExecuteCommand: (cmd: string) => void;
}

export const ChatContainer: React.FC<ChatContainerProps> = ({
  messages,
  isStreaming,
  modelsLoading,
  modelsError,
  models,
  selectedModel,
  onSelectModel,
  onSubmit,
  onExecuteCommand
}) => {
  const [prompt, setPrompt] = useState("");
  const [pendingImage, setPendingImage] = useState<string | null>(null);
  const [dragActive, setDragActive] = useState(false);
  const virtuosoRef = useRef<VirtuosoHandle>(null);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if ((!prompt.trim() && !pendingImage) || isStreaming) return;

    onSubmit(prompt, pendingImage);
    setPrompt("");
    setPendingImage(null);
  };

  // Drag & Drop
  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === "dragenter" || e.type === "dragover") setDragActive(true);
    else if (e.type === "dragleave") setDragActive(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);

    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      const file = e.dataTransfer.files[0];
      if(file.size > 1024 * 1024 * 5) {
        alert("Plik zbyt duży. Maksymalnie 5MB.");
        return;
      }

      const reader = new FileReader();
      if (file.type.startsWith('image/')) {
        reader.onload = (event) => {
          if (event.target?.result) setPendingImage(event.target.result as string);
        };
        reader.readAsDataURL(file);
      } else {
        reader.onload = (event) => {
          if (event.target?.result) {
            const content = event.target.result as string;
            const contextPrompt = `[Plik Kontekstowy: ${file.name}]\n\`\`\`\n${content.substring(0, 20000)}\n\`\`\`\n\nPrzeanalizuj treść tego pliku.`;
            setPrompt(contextPrompt);
          }
        };
        reader.readAsText(file);
      }
    }
  };

  // Message Item Renderer for Virtuoso
  const renderMessage = (index: number) => {
    const msg = messages[index];
    return (
      <motion.div
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3 }}
        className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'} py-2 px-4`}
      >
        <div
          className={`max-w-[95%] p-3 rounded-lg text-sm overflow-hidden ${
            msg.role === 'user'
              ? 'bg-[var(--matrix-accent)] text-black font-bold font-sans'
              : msg.role === 'system'
                ? 'bg-blue-900/20 text-blue-200 border border-blue-500/30 font-mono text-xs'
                : 'bg-black/20 text-[var(--matrix-text)] border border-[var(--matrix-border)] font-mono'
          }`}
        >
          {msg.role === 'system' && (
            <div className="flex items-center gap-2 mb-1 border-b border-blue-500/20 pb-1 text-blue-400">
              <Terminal size={14} />
              <span className="font-bold">SYSTEM OUTPUT</span>
            </div>
          )}

          <div className="markdown-body">
            <ReactMarkdown
              remarkPlugins={[remarkGfm]}
              components={{
                code(props) {
                  const {children, className, ...rest} = props
                  const match = /language-(\w+)/.exec(className || '')
                  return match ? (
                    <CodeBlock
                      language={match[1]}
                      value={String(children).replace(/\n$/, '')}
                      onRun={(cmd) => onExecuteCommand(cmd)}
                    />
                  ) : (
                    <code {...rest} className={className}>
                      {children}
                    </code>
                  )
                }
              }}
            >
              {msg.content}
            </ReactMarkdown>
          </div>

          {msg.role === 'assistant' && isStreaming && index === messages.length - 1 && (
            <span className="inline-block w-2 h-4 ml-1 bg-[var(--matrix-accent)] animate-pulse align-middle"></span>
          )}
        </div>
      </motion.div>
    );
  };

  return (
    <section
      className="md:col-span-2 flex flex-col gap-4 min-h-0 relative"
      onDragEnter={handleDrag}
    >
      {/* DRAG OVERLAY */}
      {dragActive && (
        <div
          className="absolute inset-0 z-50 bg-black/80 backdrop-blur-sm flex items-center justify-center border-4 border-[var(--matrix-accent)] border-dashed rounded-xl"
          onDragEnter={handleDrag}
          onDragLeave={handleDrag}
          onDragOver={handleDrag}
          onDrop={handleDrop}
        >
          <div className="text-[var(--matrix-accent)] text-2xl font-mono animate-pulse flex flex-col items-center gap-4 pointer-events-none">
            <Paperclip size={64} />
            <span>UPUŚĆ PLIK, ABY DODAĆ KONTEKST</span>
          </div>
        </div>
      )}

      <div className="glass-panel flex-1 rounded-lg border-[var(--matrix-border)] flex flex-col min-h-0">
        {/* MESSAGES LIST with Virtuoso */}
        <div className="flex-1 min-h-0">
          {messages.length === 0 ? (
            <div className="h-full flex flex-col items-center justify-center text-[var(--matrix-text-dim)] opacity-50 gap-2">
              <FileText size={48} />
              <span>Oczekiwanie na dane lub plik...</span>
            </div>
          ) : (
            <Virtuoso
              ref={virtuosoRef}
              totalCount={messages.length}
              itemContent={renderMessage}
              followOutput={'auto'}
              className="h-full scrollbar-thin"
            />
          )}
        </div>

        {/* INPUT AREA */}
        <form onSubmit={handleSubmit} className="p-4 border-t border-[var(--matrix-border)] bg-black/10 flex flex-col gap-2">
          {/* Image Preview */}
          {pendingImage && (
            <div className="relative inline-block w-fit">
              <img src={pendingImage} alt="Preview" className="h-16 w-auto rounded border border-[var(--matrix-accent)]" />
              <button
                type="button"
                onClick={() => setPendingImage(null)}
                className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full p-0.5 hover:bg-red-600"
              >
                <X size={12} />
              </button>
            </div>
          )}

          <div className="flex gap-2">
            <select
              value={selectedModel}
              onChange={(e) => onSelectModel(e.target.value)}
              className="matrix-input rounded px-2 py-2 text-sm max-w-[120px] truncate transition-colors duration-300"
              disabled={modelsLoading || !!modelsError}
            >
              {modelsLoading && <option>...</option>}
              {!!modelsError && <option>Offline</option>}
              {models?.map(m => <option key={m} value={m}>{m}</option>)}
            </select>
            <input
              value={prompt}
              onChange={(e) => setPrompt(e.currentTarget.value)}
              placeholder={pendingImage ? "Opisz ten obraz..." : "Wpisz polecenie..."}
              disabled={!!modelsError || isStreaming}
              className="flex-1 matrix-input rounded px-4 py-2 transition-colors duration-300 disabled:opacity-50"
            />
            <button
              type="submit"
              className="glass-button flex items-center gap-2"
              disabled={!!modelsError || isStreaming || (!prompt.trim() && !pendingImage)}
            >
              {isStreaming ? <RefreshCw className="animate-spin" size={16}/> : <Send size={16}/>}
            </button>
          </div>
        </form>
      </div>
    </section>
  );
};
</file>

<file path="GeminiGUI/src/components/RightSidebar.tsx">
import { useState, useEffect, useRef } from 'react';
import { Lock, Download } from 'lucide-react';
import { MemoryPanel } from './MemoryPanel';
import { BridgePanel } from './BridgePanel';

interface RightSidebarProps {
  count: number;
  onIncrement: () => void;
  onDecrement: () => void;
  onExport: () => void;
}

export const RightSidebar: React.FC<RightSidebarProps> = ({
  count,
  onIncrement,
  onDecrement,
  onExport
}) => {
  // Worker Logic
  const [workerProgress, setWorkerProgress] = useState(0);
  const [workerResult, setWorkerResult] = useState<number | null>(null);
  const [isWorking, setIsWorking] = useState(false);
  const workerRef = useRef<Worker | null>(null);

  useEffect(() => {
    workerRef.current = new Worker(
      new URL('../workers/heavyLogic.worker.ts', import.meta.url),
      { type: 'module' }
    );
    workerRef.current.onmessage = (e) => {
      const { type, value } = e.data;
      if (type === 'progress') setWorkerProgress(value);
      else if (type === 'result') {
        setWorkerResult(value);
        setIsWorking(false);
        setWorkerProgress(100);
      }
    };
    return () => { workerRef.current?.terminate(); };
  }, []);

  const startDecryption = () => {
    if (!workerRef.current) return;
    setIsWorking(true);
    setWorkerProgress(0);
    setWorkerResult(null);
    workerRef.current.postMessage(50000);
  };

  return (
    <aside className="hidden lg:flex lg:col-span-1 flex-col gap-4 overflow-y-auto pr-1">

      <MemoryPanel />
      <BridgePanel />

      {/* ACTIONS SECTION */}
      <div className="glass-panel p-4 rounded-lg flex flex-col justify-center gap-4 border-[var(--matrix-border)]">
        <div className="flex justify-between items-center text-[var(--matrix-text-dim)] border-b border-[var(--matrix-border)] pb-2">
          <span className="flex items-center gap-2 font-semibold text-sm">Akcje Sesji</span>
        </div>
        <button
          onClick={onExport}
          className="glass-button text-xs flex items-center justify-center gap-2"
          title="Eksportuj jako Markdown"
        >
          <Download size={14} /> Eksportuj Czat
        </button>
      </div>

      {/* WORKER SECTION */}
      <div className="glass-panel p-4 rounded-lg flex flex-col justify-center gap-4 border-[var(--matrix-border)]">
        <div className="flex justify-between items-center text-[var(--matrix-text-dim)] border-b border-[var(--matrix-border)] pb-2">
          <span className="flex items-center gap-2 font-semibold text-sm">
            <Lock size={16}/> Deszyfracja
          </span>
          {isWorking && <span className="text-[10px] animate-pulse text-[var(--matrix-accent)]">PRACA</span>}
        </div>

        <div className="w-full bg-black/10 rounded-full h-2.5 border border-[var(--matrix-border)] overflow-hidden">
          <div
            className="bg-[var(--matrix-accent)] h-2.5 rounded-full transition-all duration-300"
            style={{ width: `${workerProgress}%` }}
          ></div>
        </div>

        <div className="flex justify-between items-center">
          <div className="text-xs font-mono text-[var(--matrix-text-dim)]">
            {workerResult ? `Klucz: ${workerResult}` : isWorking ? `${Math.round(workerProgress)}%` : "IDLE"}
          </div>
          <button
            onClick={startDecryption}
            disabled={isWorking}
            className={`glass-button text-[10px] px-2 py-1 ${isWorking ? 'opacity-50 cursor-not-allowed' : ''}`}
          >
            {isWorking ? 'Działa...' : 'Start'}
          </button>
        </div>
      </div>

      {/* ZUSTAND SECTION */}
      <div className="glass-panel p-4 rounded-lg flex flex-col justify-center gap-4 border-[var(--matrix-border)]">
        <h2 className="text-sm font-semibold text-[var(--matrix-text-dim)] border-b border-[var(--matrix-border)] pb-2">
          Stan Systemu
        </h2>
        <div className="flex items-center justify-between text-[var(--matrix-text)]">
          <span>Licznik Sync:</span>
          <span className="text-xl font-bold text-[var(--matrix-accent)]">{count}</span>
        </div>
        <div className="flex gap-2 justify-end">
          <button onClick={onIncrement} className="glass-button text-xs px-2">+</button>
          <button onClick={onDecrement} className="glass-button text-xs px-2">-</button>
        </div>
      </div>

    </aside>
  );
};
</file>

<file path="GeminiGUI/src/components/SessionSidebar.tsx">
import { useState } from 'react';
import { Plus, Search, MessageSquare, Edit2, Trash2 } from 'lucide-react';

interface Session {
  id: string;
  title: string;
  createdAt: number;
}

interface SessionSidebarProps {
  sessions: Session[];
  currentSessionId: string | null;
  onCreateSession: () => void;
  onSelectSession: (id: string) => void;
  onDeleteSession: (id: string) => void;
  onUpdateTitle: (id: string, title: string) => void;
}

export const SessionSidebar: React.FC<SessionSidebarProps> = ({
  sessions,
  currentSessionId,
  onCreateSession,
  onSelectSession,
  onDeleteSession,
  onUpdateTitle
}) => {
  const [searchQuery, setSearchQuery] = useState("");
  const [editingSessionId, setEditingSessionId] = useState<string | null>(null);
  const [editTitle, setEditTitle] = useState("");

  const filteredSessions = sessions.filter(s =>
    s.title.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const startEditing = (session: Session) => {
    setEditingSessionId(session.id);
    setEditTitle(session.title);
  };

  const saveTitle = () => {
    if (editingSessionId) {
      onUpdateTitle(editingSessionId, editTitle);
      setEditingSessionId(null);
    }
  };

  return (
    <aside className="hidden md:flex md:col-span-1 glass-panel rounded-lg border-[var(--matrix-border)] flex-col overflow-hidden">
      {/* Toolbar */}
      <div className="p-3 border-b border-[var(--matrix-border)] flex flex-col gap-3">
        <div className="flex justify-between items-center">
          <span className="font-semibold text-[var(--matrix-text-dim)]">Sesje</span>
          <button onClick={onCreateSession} className="glass-button p-1 rounded-full">
            <Plus size={16}/>
          </button>
        </div>
        {/* Search Bar */}
        <div className="relative">
          <Search size={14} className="absolute left-2 top-2 text-[var(--matrix-text-dim)]" />
          <input
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder="Szukaj..."
            className="w-full bg-black/20 border border-[var(--matrix-border)] rounded pl-8 pr-2 py-1 text-xs text-[var(--matrix-text)] focus:outline-none focus:border-[var(--matrix-accent)]"
          />
        </div>
      </div>

      {/* List */}
      <div className="flex-1 overflow-y-auto p-2 space-y-2">
        {filteredSessions.map(session => (
          <div
            key={session.id}
            onClick={() => onSelectSession(session.id)}
            className={`p-2 rounded cursor-pointer flex justify-between items-center group transition-colors ${
              session.id === currentSessionId
                ? 'bg-[var(--matrix-accent)] text-black font-bold'
                : 'hover:bg-black/10 text-[var(--matrix-text)]'
            }`}
          >
            {editingSessionId === session.id ? (
              <input
                value={editTitle}
                onChange={(e) => setEditTitle(e.target.value)}
                onBlur={saveTitle}
                onKeyDown={(e) => e.key === 'Enter' && saveTitle()}
                autoFocus
                className="bg-white/90 text-black text-xs rounded px-1 w-full"
                onClick={(e) => e.stopPropagation()}
              />
            ) : (
              <div
                className="flex items-center gap-2 truncate flex-1"
                onDoubleClick={() => startEditing(session)}
              >
                <MessageSquare size={14} />
                <span className="truncate text-xs">{session.title}</span>
              </div>
            )}

            <div className="flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
              <button
                onClick={(e) => { e.stopPropagation(); startEditing(session); }}
                className={`hover:text-[var(--matrix-accent)] ${session.id === currentSessionId ? 'text-black/50' : 'text-[var(--matrix-text-dim)]'}`}
              >
                <Edit2 size={12} />
              </button>
              <button
                onClick={(e) => { e.stopPropagation(); onDeleteSession(session.id); }}
                className={`hover:text-red-500 ${session.id === currentSessionId ? 'text-black/50' : 'text-[var(--matrix-text-dim)]'}`}
              >
                <Trash2 size={12} />
              </button>
            </div>
          </div>
        ))}
      </div>
    </aside>
  );
};
</file>

<file path="GeminiGUI/src/components/StatusFooter.tsx">
import { useState, useEffect } from 'react';

interface StatusFooterProps {
  isStreaming: boolean;
  isWorking: boolean;
  hasError: boolean;
  selectedModel: string;
}

export const StatusFooter: React.FC<StatusFooterProps> = ({
  isStreaming,
  isWorking,
  hasError,
  selectedModel
}) => {
  const [time, setTime] = useState(new Date().toLocaleTimeString());

  useEffect(() => {
    const timer = setInterval(() => setTime(new Date().toLocaleTimeString()), 1000);
    return () => clearInterval(timer);
  }, []);

  const getStatusText = () => {
    if (isStreaming) return "ODBIERANIE STRUMIENIA DANYCH...";
    if (isWorking) return "WĄTEK ROBOCZY ZAJĘTY";
    if (hasError) return "POŁĄCZENIE PRZERWANE";
    return "SYSTEM GOTOWY";
  };

  return (
    <footer className="glass-panel rounded-lg p-2 border-[var(--matrix-border)] flex items-center justify-between text-xs font-mono shrink-0 transition-colors duration-300">
      <div className="flex items-center gap-4">
        <span className={`font-bold ${isStreaming || isWorking ? 'animate-pulse text-[var(--matrix-accent)]' : 'text-[var(--matrix-text-dim)]'}`}>
          [{getStatusText()}]
        </span>
        <span className="hidden md:inline text-[var(--matrix-text-dim)]">
          MEM: 24MB | BRIDGE: AKTYWNY
        </span>
      </div>

      <div className="flex items-center gap-4 text-[var(--matrix-text)]">
        <span className="opacity-70">MDL: {selectedModel || "BRAK"}</span>
        <span className="text-[var(--matrix-accent)]">{time}</span>
      </div>
    </footer>
  );
};
</file>

<file path="src/logger/colors.js">
/**
 * @fileoverview ANSI color codes and styling utilities for terminal output
 * Provides cross-platform color support with fallback for non-TTY environments.
 * Includes true color (24-bit), 256 color palette, gradients, and themed color schemes.
 * @module logger/colors
 *
 * Ported from ClaudeCli to GeminiCLI
 */

// ============================================================================
// ANSI Escape Codes
// ============================================================================

export const RESET = '\x1b[0m';

// ============================================================================
// Text Styles
// ============================================================================

export const Styles = Object.freeze({
  RESET: '\x1b[0m',
  BOLD: '\x1b[1m',
  DIM: '\x1b[2m',
  ITALIC: '\x1b[3m',
  UNDERLINE: '\x1b[4m',
  BLINK: '\x1b[5m',
  RAPID_BLINK: '\x1b[6m',
  INVERSE: '\x1b[7m',
  HIDDEN: '\x1b[8m',
  STRIKETHROUGH: '\x1b[9m',
  DOUBLE_UNDERLINE: '\x1b[21m',
  OVERLINE: '\x1b[53m',
  FRAMED: '\x1b[51m',
  ENCIRCLED: '\x1b[52m'
});

// ============================================================================
// Foreground Colors
// ============================================================================

export const FgColors = Object.freeze({
  BLACK: '\x1b[30m',
  RED: '\x1b[31m',
  GREEN: '\x1b[32m',
  YELLOW: '\x1b[33m',
  BLUE: '\x1b[34m',
  MAGENTA: '\x1b[35m',
  CYAN: '\x1b[36m',
  WHITE: '\x1b[37m',
  DEFAULT: '\x1b[39m',
  GRAY: '\x1b[90m',
  GREY: '\x1b[90m',
  BRIGHT_RED: '\x1b[91m',
  BRIGHT_GREEN: '\x1b[92m',
  BRIGHT_YELLOW: '\x1b[93m',
  BRIGHT_BLUE: '\x1b[94m',
  BRIGHT_MAGENTA: '\x1b[95m',
  BRIGHT_CYAN: '\x1b[96m',
  BRIGHT_WHITE: '\x1b[97m'
});

// ============================================================================
// Background Colors
// ============================================================================

export const BgColors = Object.freeze({
  BLACK: '\x1b[40m',
  RED: '\x1b[41m',
  GREEN: '\x1b[42m',
  YELLOW: '\x1b[43m',
  BLUE: '\x1b[44m',
  MAGENTA: '\x1b[45m',
  CYAN: '\x1b[46m',
  WHITE: '\x1b[47m',
  DEFAULT: '\x1b[49m',
  BRIGHT_BLACK: '\x1b[100m',
  BRIGHT_RED: '\x1b[101m',
  BRIGHT_GREEN: '\x1b[102m',
  BRIGHT_YELLOW: '\x1b[103m',
  BRIGHT_BLUE: '\x1b[104m',
  BRIGHT_MAGENTA: '\x1b[105m',
  BRIGHT_CYAN: '\x1b[106m',
  BRIGHT_WHITE: '\x1b[107m'
});

// ============================================================================
// Combined Colors Object (Backwards Compatible)
// ============================================================================

export const COLORS = Object.freeze({
  reset: RESET,
  bright: Styles.BOLD,
  dim: Styles.DIM,
  italic: Styles.ITALIC,
  underline: Styles.UNDERLINE,
  inverse: Styles.INVERSE,
  hidden: Styles.HIDDEN,
  strikethrough: Styles.STRIKETHROUGH,
  black: FgColors.BLACK,
  red: FgColors.RED,
  green: FgColors.GREEN,
  yellow: FgColors.YELLOW,
  blue: FgColors.BLUE,
  magenta: FgColors.MAGENTA,
  cyan: FgColors.CYAN,
  white: FgColors.WHITE,
  gray: FgColors.GRAY,
  grey: FgColors.GREY,
  brightRed: FgColors.BRIGHT_RED,
  brightGreen: FgColors.BRIGHT_GREEN,
  brightYellow: FgColors.BRIGHT_YELLOW,
  brightBlue: FgColors.BRIGHT_BLUE,
  brightMagenta: FgColors.BRIGHT_MAGENTA,
  brightCyan: FgColors.BRIGHT_CYAN,
  brightWhite: FgColors.BRIGHT_WHITE,
  bgBlack: BgColors.BLACK,
  bgRed: BgColors.RED,
  bgGreen: BgColors.GREEN,
  bgYellow: BgColors.YELLOW,
  bgBlue: BgColors.BLUE,
  bgMagenta: BgColors.MAGENTA,
  bgCyan: BgColors.CYAN,
  bgWhite: BgColors.WHITE,
  bgBrightBlack: BgColors.BRIGHT_BLACK,
  bgBrightRed: BgColors.BRIGHT_RED,
  bgBrightGreen: BgColors.BRIGHT_GREEN,
  bgBrightYellow: BgColors.BRIGHT_YELLOW,
  bgBrightBlue: BgColors.BRIGHT_BLUE,
  bgBrightMagenta: BgColors.BRIGHT_MAGENTA,
  bgBrightCyan: BgColors.BRIGHT_CYAN,
  bgBrightWhite: BgColors.BRIGHT_WHITE
});

// ============================================================================
// Color Detection
// ============================================================================

export function supportsColors() {
  if (process.env.FORCE_COLOR !== undefined) {
    return process.env.FORCE_COLOR !== '0';
  }
  if (process.env.NO_COLOR !== undefined) {
    return false;
  }
  if (!process.stdout.isTTY) {
    return false;
  }
  const term = process.env.TERM || '';
  if (term === 'dumb') {
    return false;
  }
  if (process.env.CI) {
    const supportedCI = ['TRAVIS', 'CIRCLECI', 'GITHUB_ACTIONS', 'GITLAB_CI', 'BUILDKITE'];
    if (supportedCI.some(ci => process.env[ci])) {
      return true;
    }
  }
  if (process.platform === 'win32') {
    const osRelease = require('os').release().split('.');
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return true;
    }
    return false;
  }
  return true;
}

export function getColorDepth() {
  if (!supportsColors()) return 1;
  const colorTerm = process.env.COLORTERM || '';
  if (colorTerm === 'truecolor' || colorTerm === '24bit') return 24;
  const termProgram = process.env.TERM_PROGRAM || '';
  if (['iTerm.app', 'Hyper', 'Apple_Terminal', 'vscode'].includes(termProgram)) return 24;
  const term = process.env.TERM || '';
  if (term.includes('256') || term.includes('256color')) return 8;
  if (process.env.WT_SESSION) return 24;
  return 4;
}

export function supportsTrueColor() {
  return getColorDepth() === 24;
}

export function supports256Colors() {
  return getColorDepth() >= 8;
}

// ============================================================================
// Color Application Functions
// ============================================================================

export function colorize(text, colorCode) {
  if (!supportsColors()) return text;
  return `${colorCode}${text}${RESET}`;
}

export function createColorFormatter(colorCode) {
  return (text) => colorize(text, colorCode);
}

export function stripAnsi(text) {
  return text.replace(/\x1b\[[0-9;]*m/g, '');
}

export function visibleLength(text) {
  return stripAnsi(text).length;
}

// ============================================================================
// Convenience Color Functions
// ============================================================================

export const red = createColorFormatter(FgColors.RED);
export const green = createColorFormatter(FgColors.GREEN);
export const yellow = createColorFormatter(FgColors.YELLOW);
export const blue = createColorFormatter(FgColors.BLUE);
export const magenta = createColorFormatter(FgColors.MAGENTA);
export const cyan = createColorFormatter(FgColors.CYAN);
export const white = createColorFormatter(FgColors.WHITE);
export const gray = createColorFormatter(FgColors.GRAY);
export const grey = gray;
export const black = createColorFormatter(FgColors.BLACK);

export const bold = createColorFormatter(Styles.BOLD);
export const dim = createColorFormatter(Styles.DIM);
export const italic = createColorFormatter(Styles.ITALIC);
export const underline = createColorFormatter(Styles.UNDERLINE);
export const inverse = createColorFormatter(Styles.INVERSE);
export const strikethrough = createColorFormatter(Styles.STRIKETHROUGH);

// ============================================================================
// Semantic Color Functions
// ============================================================================

export function error(text) {
  return colorize(text, FgColors.RED);
}

export function warning(text) {
  return colorize(text, FgColors.YELLOW);
}

export function success(text) {
  return colorize(text, FgColors.GREEN);
}

export function info(text) {
  return colorize(text, FgColors.CYAN);
}

export function debug(text) {
  return colorize(text, FgColors.GRAY);
}

// ============================================================================
// 256-Color Support
// ============================================================================

export function fg256(colorCode) {
  const code = Math.max(0, Math.min(255, Math.floor(colorCode)));
  return `\x1b[38;5;${code}m`;
}

export function bg256(colorCode) {
  const code = Math.max(0, Math.min(255, Math.floor(colorCode)));
  return `\x1b[48;5;${code}m`;
}

export function color256(text, colorCode) {
  if (!supports256Colors()) return text;
  return `${fg256(colorCode)}${text}${RESET}`;
}

export function rgbTo256(r, g, b) {
  if (r === g && g === b) {
    if (r < 8) return 16;
    if (r > 248) return 231;
    return Math.round((r - 8) / 247 * 24) + 232;
  }
  const rIndex = Math.round(r / 255 * 5);
  const gIndex = Math.round(g / 255 * 5);
  const bIndex = Math.round(b / 255 * 5);
  return 16 + (36 * rIndex) + (6 * gIndex) + bIndex;
}

// ============================================================================
// True Color (24-bit) Support
// ============================================================================

export function fgRGB(r, g, b) {
  const rc = Math.max(0, Math.min(255, Math.floor(r)));
  const gc = Math.max(0, Math.min(255, Math.floor(g)));
  const bc = Math.max(0, Math.min(255, Math.floor(b)));
  return `\x1b[38;2;${rc};${gc};${bc}m`;
}

export function bgRGB(r, g, b) {
  const rc = Math.max(0, Math.min(255, Math.floor(r)));
  const gc = Math.max(0, Math.min(255, Math.floor(g)));
  const bc = Math.max(0, Math.min(255, Math.floor(b)));
  return `\x1b[48;2;${rc};${gc};${bc}m`;
}

export function rgb(text, r, g, b) {
  if (!supportsTrueColor()) {
    if (supports256Colors()) {
      return color256(text, rgbTo256(r, g, b));
    }
    return text;
  }
  return `${fgRGB(r, g, b)}${text}${RESET}`;
}

export function hexToRgb(hex) {
  let clean = hex.replace('#', '');
  if (clean.length === 3) {
    clean = clean.split('').map(c => c + c).join('');
  }
  const r = parseInt(clean.substring(0, 2), 16) || 0;
  const g = parseInt(clean.substring(2, 4), 16) || 0;
  const b = parseInt(clean.substring(4, 6), 16) || 0;
  return { r, g, b };
}

export function hex(text, hexColor) {
  const { r, g, b } = hexToRgb(hexColor);
  return rgb(text, r, g, b);
}

// ============================================================================
// Gradient Support
// ============================================================================

export function interpolateColor(color1, color2, factor) {
  return {
    r: Math.round(color1.r + (color2.r - color1.r) * factor),
    g: Math.round(color1.g + (color2.g - color1.g) * factor),
    b: Math.round(color1.b + (color2.b - color1.b) * factor)
  };
}

export function createGradientColors(colors, steps) {
  if (colors.length < 2) {
    throw new Error('Gradient requires at least 2 colors');
  }
  const rgbColors = colors.map(c => hexToRgb(c));
  const result = [];
  const segmentSteps = Math.ceil(steps / (colors.length - 1));
  for (let i = 0; i < colors.length - 1; i++) {
    const startColor = rgbColors[i];
    const endColor = rgbColors[i + 1];
    for (let j = 0; j < segmentSteps && result.length < steps; j++) {
      const factor = j / segmentSteps;
      result.push(interpolateColor(startColor, endColor, factor));
    }
  }
  while (result.length < steps) {
    result.push(rgbColors[rgbColors.length - 1]);
  }
  return result.slice(0, steps);
}

export function gradient(text, colors) {
  if (!supportsTrueColor() && !supports256Colors()) return text;
  const chars = stripAnsi(text).split('');
  if (chars.length === 0) return text;
  const gradientColors = createGradientColors(colors, chars.length);
  let result = '';
  for (let i = 0; i < chars.length; i++) {
    const { r, g, b } = gradientColors[i];
    if (supportsTrueColor()) {
      result += `${fgRGB(r, g, b)}${chars[i]}`;
    } else {
      result += `${fg256(rgbTo256(r, g, b))}${chars[i]}`;
    }
  }
  return result + RESET;
}

export function rainbow(text) {
  return gradient(text, ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3']);
}

// ============================================================================
// Predefined Gradients
// ============================================================================

export const Gradients = Object.freeze({
  RAINBOW: ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'],
  MATRIX: ['#00ff00', '#003300', '#00ff00', '#009900'],
  CYBERPUNK: ['#ff00ff', '#00ffff', '#ff0080', '#00ff00'],
  SUNSET: ['#ff512f', '#f09819', '#ff5e62', '#ff9966'],
  OCEAN: ['#2193b0', '#6dd5ed', '#00d2ff', '#3a7bd5']
});

// ============================================================================
// Progress Bar
// ============================================================================

export function progressBar(current, total, options = {}) {
  const width = options.width || 30;
  const completeChar = options.completeChar || '\u2588';
  const incompleteChar = options.incompleteChar || '\u2591';
  const percent = Math.min(1, Math.max(0, current / total));
  const completeWidth = Math.round(width * percent);
  const incompleteWidth = width - completeWidth;
  let complete = completeChar.repeat(completeWidth);
  let incomplete = incompleteChar.repeat(incompleteWidth);
  if (options.completeColor) {
    complete = hex(complete, options.completeColor);
  }
  if (options.incompleteColor) {
    incomplete = hex(incomplete, options.incompleteColor);
  }
  return `${complete}${incomplete} ${Math.round(percent * 100)}%`;
}

// ============================================================================
// Default Export
// ============================================================================

export default {
  COLORS,
  Styles,
  FgColors,
  BgColors,
  RESET,
  supportsColors,
  getColorDepth,
  supportsTrueColor,
  supports256Colors,
  colorize,
  createColorFormatter,
  stripAnsi,
  visibleLength,
  red, green, yellow, blue, magenta, cyan, white, gray, grey, black,
  bold, dim, italic, underline, inverse, strikethrough,
  error, warning, success, info, debug,
  fg256, bg256, color256, rgbTo256,
  fgRGB, bgRGB, rgb, hexToRgb, hex,
  interpolateColor, createGradientColors, gradient, rainbow,
  Gradients,
  progressBar
};
</file>

<file path="src/logger/index.js">
/**
 * @fileoverview Enhanced Logger with async writing, rotation, colors, and performance optimizations
 * ES Module - Singleton Pattern
 * Correlation ID Support via AsyncLocalStorage
 *
 * Ported from ClaudeCli to GeminiCLI
 * @module logger
 */

import fs from 'fs';
import fsPromises from 'fs/promises';
import path from 'path';
import { AsyncLocalStorage } from 'async_hooks';
import crypto from 'crypto';
import { COLORS } from './colors.js';

// Re-export colors for convenience
export { COLORS } from './colors.js';

// ==================== Correlation ID Support ====================

const correlationStorage = new AsyncLocalStorage();

/**
 * Generates a unique correlation ID for request tracing
 * Format: gemini-{timestamp}-{random}
 */
export function generateCorrelationId() {
  const timestamp = Date.now().toString(36);
  const random = crypto.randomBytes(4).toString('hex');
  return `gemini-${timestamp}-${random}`;
}

function getCurrentCorrelationId() {
  const store = correlationStorage.getStore();
  return store?.correlationId || null;
}

/**
 * Executes a function within a correlation ID context
 */
export function withCorrelationId(correlationId, fn) {
  return correlationStorage.run({ correlationId }, fn);
}

/**
 * Express middleware for correlation ID tracking
 */
export function correlationMiddleware(req, res, next) {
  const existingId = req.headers['x-correlation-id'] ||
                     req.headers['x-request-id'] ||
                     req.headers['traceparent'];
  const correlationId = existingId || generateCorrelationId();
  res.setHeader('X-Correlation-ID', correlationId);
  correlationStorage.run({ correlationId }, () => {
    req.correlationId = correlationId;
    next();
  });
}

// Log level configuration
const LOG_LEVELS = {
  error: { priority: 0, color: COLORS.red, bgColor: COLORS.bgRed, label: 'ERROR' },
  warn: { priority: 1, color: COLORS.yellow, bgColor: COLORS.bgYellow, label: 'WARN' },
  info: { priority: 2, color: COLORS.cyan, label: 'INFO' },
  http: { priority: 3, color: COLORS.magenta, label: 'HTTP' },
  debug: { priority: 4, color: COLORS.gray, label: 'DEBUG' },
  trace: { priority: 5, color: COLORS.dim + COLORS.gray, label: 'TRACE' },
};

// Default configuration
const DEFAULT_CONFIG = {
  level: 'info',
  rotation: {
    enabled: true,
    maxSize: 10 * 1024 * 1024, // 10MB
    maxFiles: 10,
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
    compress: false,
  },
  console: {
    enabled: true,
    colors: true,
    timestamps: true,
    level: 'info',
  },
  file: {
    enabled: true,
    prettyPrint: false,
    timestamps: true,
  },
  performance: {
    batchSize: 100,
    flushInterval: 1000,
    asyncWrite: true,
  },
};

/**
 * High-performance Logger with async file writing, rotation, and colored output
 */
class Logger {
  static #instance = null;

  #config;
  #logDir;
  #currentLogFile;
  #currentFileSize = 0;
  #writeBuffer = [];
  #flushTimer = null;
  #isWriting = false;
  #writeQueue = [];
  #initialized = false;
  #currentDate = null;

  constructor(config = {}) {
    if (Logger.#instance) {
      throw new Error('Logger is a singleton. Use Logger.getInstance() instead.');
    }
    this.#config = this.#mergeConfig(DEFAULT_CONFIG, config);
    this.#logDir = path.join(process.cwd(), '.gemini-data/logs');
    this.#currentDate = this.#getDateString();
    this.#ensureLogDirSync();
    this.#currentLogFile = this.#getLogFileName();
    this.#getCurrentFileSize();
    this.#startFlushTimer();
    this.#setupExitHandlers();
    Logger.#instance = this;
  }

  static getInstance(config = {}) {
    if (!Logger.#instance) {
      new Logger(config);
    }
    return Logger.#instance;
  }

  static resetInstance() {
    if (Logger.#instance) {
      Logger.#instance.#stopFlushTimer();
      Logger.#instance.flush();
    }
    Logger.#instance = null;
  }

  configure(config) {
    this.#config = this.#mergeConfig(this.#config, config);
    return this;
  }

  getConfig() {
    return { ...this.#config };
  }

  // ==================== Core Logging Methods ====================

  error(message, meta = {}) { this.#log('error', message, meta); }
  warn(message, meta = {}) { this.#log('warn', message, meta); }
  info(message, meta = {}) { this.#log('info', message, meta); }
  http(message, meta = {}) { this.#log('http', message, meta); }
  debug(message, meta = {}) { this.#log('debug', message, meta); }
  trace(message, meta = {}) { this.#log('trace', message, meta); }
  log(level, message, meta = {}) { this.#log(level, message, meta); }

  // ==================== Internal Methods ====================

  #log(level, message, meta = {}) {
    const levelConfig = LOG_LEVELS[level];
    if (!levelConfig) {
      console.error(`Unknown log level: ${level}`);
      return;
    }
    const configLevel = LOG_LEVELS[this.#config.level];
    if (levelConfig.priority > configLevel.priority) return;

    const timestamp = new Date().toISOString();
    const correlationId = meta.correlationId || getCurrentCorrelationId();
    const logEntry = {
      timestamp,
      level: levelConfig.label,
      ...(correlationId && { correlationId }),
      message,
      ...meta,
    };

    if (meta.correlationId) {
      delete logEntry.correlationId;
      logEntry.correlationId = meta.correlationId;
    }

    if (this.#config.console.enabled) {
      const consoleLevel = LOG_LEVELS[this.#config.console.level];
      if (levelConfig.priority <= consoleLevel.priority) {
        this.#writeToConsole(level, timestamp, message, meta, correlationId);
      }
    }

    if (this.#config.file.enabled) {
      this.#addToBuffer(logEntry);
    }
  }

  #writeToConsole(level, timestamp, message, meta, correlationId = null) {
    const levelConfig = LOG_LEVELS[level];
    const useColors = this.#config.console.colors && process.stdout.isTTY;
    const isProd = process.env.NODE_ENV === 'production';

    let output = '';

    if (isProd) {
      const logObj = {
        timestamp,
        level: levelConfig.label,
        ...(correlationId && { correlationId }),
        ...(meta.module && { module: meta.module }),
        message,
        ...meta,
      };
      if (meta.module) delete logObj.module;
      output = JSON.stringify(logObj);
    } else if (useColors) {
      const timeStr = this.#config.console.timestamps
        ? `${COLORS.gray}[${timestamp}]${COLORS.reset} `
        : '';
      const levelStr = `${levelConfig.color}${COLORS.bright}${levelConfig.label.padEnd(5)}${COLORS.reset}`;
      const moduleStr = meta.module || meta.context
        ? `${COLORS.cyan}[${meta.module || meta.context}]${COLORS.reset} `
        : '';
      const corrStr = correlationId
        ? `${COLORS.dim}(${correlationId.slice(-8)})${COLORS.reset} `
        : '';
      const messageStr = level === 'error'
        ? `${COLORS.red}${message}${COLORS.reset}`
        : message;
      output = `${timeStr}${levelStr} ${moduleStr}${corrStr}${messageStr}`;

      const displayMeta = { ...meta };
      delete displayMeta.module;
      delete displayMeta.context;
      delete displayMeta.correlationId;

      if (Object.keys(displayMeta).length > 0) {
        const metaStr = JSON.stringify(displayMeta, null, 0);
        output += ` ${COLORS.dim}${metaStr}${COLORS.reset}`;
      }
    } else {
      const timeStr = this.#config.console.timestamps ? `[${timestamp}] ` : '';
      const moduleStr = meta.module || meta.context ? `[${meta.module || meta.context}] ` : '';
      const corrStr = correlationId ? `(${correlationId.slice(-8)}) ` : '';
      output = `${timeStr}[${levelConfig.label}] ${moduleStr}${corrStr}${message}`;

      const displayMeta = { ...meta };
      delete displayMeta.module;
      delete displayMeta.context;
      delete displayMeta.correlationId;

      if (Object.keys(displayMeta).length > 0) {
        output += ` ${JSON.stringify(displayMeta)}`;
      }
    }

    if (level === 'error') {
      console.error(output);
    } else if (level === 'warn') {
      console.warn(output);
    } else {
      console.log(output);
    }
  }

  #addToBuffer(logEntry) {
    const logLine = this.#config.file.prettyPrint
      ? JSON.stringify(logEntry, null, 2) + '\n'
      : JSON.stringify(logEntry) + '\n';
    this.#writeBuffer.push(logLine);
    if (this.#writeBuffer.length >= this.#config.performance.batchSize) {
      this.flush();
    }
  }

  async flush() {
    if (this.#writeBuffer.length === 0) return;

    const currentDate = this.#getDateString();
    if (currentDate !== this.#currentDate) {
      this.#currentDate = currentDate;
      this.#currentLogFile = this.#getLogFileName();
      this.#currentFileSize = 0;
    }

    const content = this.#writeBuffer.join('');
    this.#writeBuffer = [];

    if (this.#config.rotation.enabled) {
      await this.#checkRotation(content.length);
    }

    if (this.#config.performance.asyncWrite) {
      await this.#writeAsync(content);
    } else {
      this.#writeSync(content);
    }
  }

  flushSync() {
    if (this.#writeBuffer.length === 0) return;
    const content = this.#writeBuffer.join('');
    this.#writeBuffer = [];
    this.#writeSync(content);
  }

  async #writeAsync(content) {
    try {
      await fsPromises.appendFile(this.#currentLogFile, content, { encoding: 'utf8' });
      this.#currentFileSize += Buffer.byteLength(content, 'utf8');
    } catch (err) {
      console.error('Async write failed, falling back to sync:', err.message);
      this.#writeSync(content);
    }
  }

  #writeSync(content) {
    try {
      fs.appendFileSync(this.#currentLogFile, content, { encoding: 'utf8' });
      this.#currentFileSize += Buffer.byteLength(content, 'utf8');
    } catch (err) {
      console.error('CRITICAL: Failed to write to log file:', err.message);
    }
  }

  // ==================== Log Rotation ====================

  async #checkRotation(incomingSize) {
    const { maxSize } = this.#config.rotation;
    if (this.#currentFileSize + incomingSize > maxSize) {
      await this.#rotateLog();
    }
  }

  async #rotateLog() {
    const { maxFiles } = this.#config.rotation;
    const baseName = this.#currentLogFile;

    try {
      for (let i = maxFiles - 1; i >= 1; i--) {
        const oldFile = `${baseName}.${i}`;
        const newFile = `${baseName}.${i + 1}`;
        try {
          await fsPromises.access(oldFile);
          if (i === maxFiles - 1) {
            await fsPromises.unlink(oldFile);
          } else {
            await fsPromises.rename(oldFile, newFile);
          }
        } catch { /* File doesn't exist */ }
      }
      try {
        await fsPromises.access(baseName);
        await fsPromises.rename(baseName, `${baseName}.1`);
      } catch { /* Current file doesn't exist */ }
      this.#currentFileSize = 0;
    } catch (err) {
      console.error('Log rotation failed:', err.message);
    }
    await this.#cleanOldLogs();
  }

  async #cleanOldLogs() {
    const { maxAge } = this.#config.rotation;
    const now = Date.now();
    try {
      const files = await fsPromises.readdir(this.#logDir);
      for (const file of files) {
        if (!file.startsWith('gemini-') || !file.includes('.log')) continue;
        const filePath = path.join(this.#logDir, file);
        const stats = await fsPromises.stat(filePath);
        if (now - stats.mtimeMs > maxAge) {
          await fsPromises.unlink(filePath);
          this.debug(`Deleted old log file: ${file}`);
        }
      }
    } catch { /* Ignore cleanup errors */ }
  }

  // ==================== Utility Methods ====================

  #mergeConfig(target, source) {
    const result = { ...target };
    for (const key of Object.keys(source)) {
      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
        result[key] = this.#mergeConfig(target[key] || {}, source[key]);
      } else if (source[key] !== undefined) {
        result[key] = source[key];
      }
    }
    return result;
  }

  #getDateString() {
    return new Date().toISOString().split('T')[0];
  }

  #getLogFileName() {
    return path.join(this.#logDir, `gemini-${this.#currentDate}.log`);
  }

  #ensureLogDirSync() {
    if (!fs.existsSync(this.#logDir)) {
      fs.mkdirSync(this.#logDir, { recursive: true });
    }
  }

  #getCurrentFileSize() {
    try {
      const stats = fs.statSync(this.#currentLogFile);
      this.#currentFileSize = stats.size;
    } catch {
      this.#currentFileSize = 0;
    }
  }

  #startFlushTimer() {
    if (this.#flushTimer) return;
    this.#flushTimer = setInterval(() => {
      this.flush().catch(err => console.error('Auto-flush failed:', err.message));
    }, this.#config.performance.flushInterval);
    this.#flushTimer.unref();
  }

  #stopFlushTimer() {
    if (this.#flushTimer) {
      clearInterval(this.#flushTimer);
      this.#flushTimer = null;
    }
  }

  #setupExitHandlers() {
    const exitHandler = () => {
      this.#stopFlushTimer();
      this.flushSync();
    };
    process.on('exit', exitHandler);
    process.on('SIGINT', () => { exitHandler(); process.exit(0); });
    process.on('SIGTERM', () => { exitHandler(); process.exit(0); });
    process.on('uncaughtException', (err) => {
      this.error('Uncaught exception', { error: err.message, stack: err.stack });
      exitHandler();
      process.exit(1);
    });
  }

  // ==================== Child Logger Factory ====================

  child(context, options = {}) {
    const parent = this;
    const fixedCorrelationId = options.correlationId || null;

    return {
      error: (msg, meta = {}) => parent.error(msg, { ...meta, context, ...(fixedCorrelationId && { correlationId: fixedCorrelationId }) }),
      warn: (msg, meta = {}) => parent.warn(msg, { ...meta, context, ...(fixedCorrelationId && { correlationId: fixedCorrelationId }) }),
      info: (msg, meta = {}) => parent.info(msg, { ...meta, context, ...(fixedCorrelationId && { correlationId: fixedCorrelationId }) }),
      http: (msg, meta = {}) => parent.http(msg, { ...meta, context, ...(fixedCorrelationId && { correlationId: fixedCorrelationId }) }),
      debug: (msg, meta = {}) => parent.debug(msg, { ...meta, context, ...(fixedCorrelationId && { correlationId: fixedCorrelationId }) }),
      trace: (msg, meta = {}) => parent.trace(msg, { ...meta, context, ...(fixedCorrelationId && { correlationId: fixedCorrelationId }) }),
      log: (level, msg, meta = {}) => parent.log(level, msg, { ...meta, context, ...(fixedCorrelationId && { correlationId: fixedCorrelationId }) }),
      child: (childContext) => parent.child(`${context}:${childContext}`, { correlationId: fixedCorrelationId }),
      withCorrelation: (correlationId) => parent.child(context, { correlationId }),
      getContext: () => context,
      getCorrelationId: () => fixedCorrelationId,
    };
  }

  withCorrelation(correlationId) {
    return this.child('root', { correlationId });
  }
}

// ==================== Exports ====================

const logger = Logger.getInstance();

export const createLogger = (context, options = {}) => logger.child(context, options);
export const configureLogger = (config) => logger.configure(config);
export const getLoggerConfig = () => logger.getConfig();
export const LogLevels = Object.keys(LOG_LEVELS);

export { Logger };
export default logger;
</file>

<file path="src/tools/base-tool.js">
/**
 * @fileoverview BaseTool - Abstract base class for all tools
 * Provides unified interface, validation, error handling, and timeout support
 *
 * Ported from ClaudeCli to GeminiCLI
 * @module tools/base-tool
 */

import { z } from 'zod';
import { createLogger } from '../logger/index.js';
import { ValidationError, ToolExecutionError, TimeoutError } from './errors.js';

/**
 * Standard result format for all tool operations
 */
export class ToolResult {
  constructor({ success, data = null, error = null, metadata = {} }) {
    this.success = success;
    this.data = data;
    this.error = error;
    this.metadata = {
      timestamp: new Date().toISOString(),
      ...metadata
    };
  }

  static ok(data, metadata = {}) {
    return new ToolResult({ success: true, data, metadata });
  }

  static fail(error, metadata = {}) {
    return new ToolResult({
      success: false,
      error: error instanceof Error ? error.message : error,
      metadata
    });
  }

  toJSON() {
    return {
      success: this.success,
      ...(this.success ? { data: this.data } : { error: this.error }),
      metadata: this.metadata
    };
  }
}

/**
 * Abstract base class for tools
 * @abstract
 */
export class BaseTool {
  /**
   * @param {Object} config - Tool configuration
   * @param {string} config.name - Unique tool identifier
   * @param {string} config.description - Human-readable description
   * @param {z.ZodSchema} config.inputSchema - Zod schema for input validation
   * @param {number} [config.timeoutMs=30000] - Execution timeout in milliseconds
   * @param {string[]} [config.requiredPermissions=[]] - Required permissions
   */
  constructor({ name, description, inputSchema, timeoutMs = 30000, requiredPermissions = [] }) {
    if (new.target === BaseTool) {
      throw new Error('BaseTool is abstract and cannot be instantiated directly');
    }

    if (!name || typeof name !== 'string') {
      throw new Error('Tool name is required');
    }

    if (!description || typeof description !== 'string') {
      throw new Error('Tool description is required');
    }

    if (!(inputSchema instanceof z.ZodType)) {
      throw new Error('inputSchema must be a Zod schema');
    }

    this.name = name;
    this.description = description;
    this.inputSchema = inputSchema;
    this.timeoutMs = timeoutMs;
    this.requiredPermissions = requiredPermissions;
    this.logger = createLogger(name);
  }

  /**
   * Validate input against the schema
   */
  validateInput(input) {
    const result = this.inputSchema.safeParse(input);

    if (!result.success) {
      const issues = result.error.issues || result.error.errors || [];
      const errors = issues.map(e => `${e.path?.join('.') || ''}: ${e.message}`).join('; ');
      throw new ValidationError(`Input validation failed for ${this.name}: ${errors || result.error.message || 'Unknown validation error'}`);
    }

    return result.data;
  }

  /**
   * Convert Zod schema to JSON Schema for MCP compatibility
   */
  getJsonSchema() {
    return zodToJsonSchema(this.inputSchema);
  }

  /**
   * Get tool definition for MCP registration
   */
  getDefinition() {
    return {
      name: this.name,
      description: this.description,
      inputSchema: this.getJsonSchema()
    };
  }

  /**
   * Execute the tool with validation, timeout, and error handling
   */
  async execute(rawInput) {
    const startTime = Date.now();

    try {
      const validatedInput = this.validateInput(rawInput);
      this.logger.info(`Executing ${this.name}`, { input: this.sanitizeForLog(validatedInput) });

      const result = await this.withTimeout(
        this.run(validatedInput),
        this.timeoutMs
      );

      const duration = Date.now() - startTime;
      this.logger.info(`${this.name} completed successfully`, { durationMs: duration });

      return ToolResult.ok(result, { durationMs: duration, tool: this.name });

    } catch (error) {
      const duration = Date.now() - startTime;
      this.logger.error(`${this.name} failed`, {
        error: error.message,
        durationMs: duration,
        stack: error.stack
      });

      if (error instanceof ValidationError || error instanceof TimeoutError) {
        return ToolResult.fail(error.message, { durationMs: duration, tool: this.name });
      }

      return ToolResult.fail(
        error.message || 'Unknown error occurred',
        { durationMs: duration, tool: this.name, errorCode: error.code }
      );
    }
  }

  /**
   * Abstract method - must be implemented by subclasses
   * @abstract
   */
  async run(input) {
    throw new Error(`${this.name}: run() method must be implemented`);
  }

  /**
   * Wrap a promise with timeout
   */
  async withTimeout(promise, ms) {
    let timeoutId;

    const timeoutPromise = new Promise((_, reject) => {
      timeoutId = setTimeout(() => {
        reject(new TimeoutError(`${this.name} timed out after ${ms}ms`));
      }, ms);
    });

    try {
      const result = await Promise.race([promise, timeoutPromise]);
      clearTimeout(timeoutId);
      return result;
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  }

  /**
   * Sanitize input for logging (remove sensitive data)
   */
  sanitizeForLog(input) {
    const sensitiveKeys = ['password', 'token', 'secret', 'key', 'credential', 'auth'];
    const sanitized = { ...input };

    for (const key of Object.keys(sanitized)) {
      if (sensitiveKeys.some(s => key.toLowerCase().includes(s))) {
        sanitized[key] = '[REDACTED]';
      } else if (typeof sanitized[key] === 'string' && sanitized[key].length > 500) {
        sanitized[key] = sanitized[key].substring(0, 100) + '...[TRUNCATED]';
      }
    }

    return sanitized;
  }
}

/**
 * Convert Zod schema to JSON Schema (simplified implementation)
 */
function zodToJsonSchema(zodSchema) {
  const def = zodSchema._def;

  if (def.typeName === 'ZodObject') {
    const properties = {};
    const required = [];

    for (const [key, value] of Object.entries(def.shape())) {
      properties[key] = zodToJsonSchema(value);
      if (!value.isOptional?.() && !value._def.typeName?.includes('Optional')) {
        required.push(key);
      }
    }

    return {
      type: 'object',
      properties,
      ...(required.length > 0 && { required })
    };
  }

  if (def.typeName === 'ZodString') {
    const schema = { type: 'string' };
    if (def.checks) {
      for (const check of def.checks) {
        if (check.kind === 'min') schema.minLength = check.value;
        if (check.kind === 'max') schema.maxLength = check.value;
      }
    }
    if (def.description) schema.description = def.description;
    return schema;
  }

  if (def.typeName === 'ZodNumber') {
    const schema = { type: 'number' };
    if (def.checks) {
      for (const check of def.checks) {
        if (check.kind === 'min') schema.minimum = check.value;
        if (check.kind === 'max') schema.maximum = check.value;
      }
    }
    if (def.description) schema.description = def.description;
    return schema;
  }

  if (def.typeName === 'ZodBoolean') {
    return { type: 'boolean', ...(def.description && { description: def.description }) };
  }

  if (def.typeName === 'ZodArray') {
    return {
      type: 'array',
      items: zodToJsonSchema(def.type),
      ...(def.description && { description: def.description })
    };
  }

  if (def.typeName === 'ZodEnum') {
    return {
      type: 'string',
      enum: def.values,
      ...(def.description && { description: def.description })
    };
  }

  if (def.typeName === 'ZodOptional' || def.typeName === 'ZodNullable') {
    return zodToJsonSchema(def.innerType);
  }

  if (def.typeName === 'ZodDefault') {
    const schema = zodToJsonSchema(def.innerType);
    schema.default = def.defaultValue();
    return schema;
  }

  return { type: 'string' };
}

export default BaseTool;
</file>

<file path="src/tools/errors.js">
/**
 * @fileoverview Custom error classes for tools
 * @module tools/errors
 */

/**
 * Base application error
 */
export class AppError extends Error {
  constructor(message, code = 'APP_ERROR', statusCode = 500) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    Error.captureStackTrace(this, this.constructor);
  }

  toJSON() {
    return {
      error: this.name,
      message: this.message,
      code: this.code,
      statusCode: this.statusCode
    };
  }
}

/**
 * Validation error - thrown when input validation fails
 */
export class ValidationError extends AppError {
  constructor(message, field = null) {
    super(message, 'VALIDATION_ERROR', 400);
    this.field = field;
  }

  toJSON() {
    return {
      ...super.toJSON(),
      field: this.field
    };
  }
}

/**
 * Tool execution error - thrown when a tool fails to execute
 */
export class ToolExecutionError extends AppError {
  constructor(message, toolName = null, details = null) {
    super(message, 'TOOL_EXECUTION_ERROR', 500);
    this.toolName = toolName;
    this.details = details;
  }

  toJSON() {
    return {
      ...super.toJSON(),
      toolName: this.toolName,
      details: this.details
    };
  }
}

/**
 * Timeout error - thrown when operation exceeds time limit
 */
export class TimeoutError extends AppError {
  constructor(message, timeoutMs = null) {
    super(message, 'TIMEOUT_ERROR', 408);
    this.timeoutMs = timeoutMs;
  }

  toJSON() {
    return {
      ...super.toJSON(),
      timeoutMs: this.timeoutMs
    };
  }
}

/**
 * Not found error
 */
export class NotFoundError extends AppError {
  constructor(message, resource = null) {
    super(message, 'NOT_FOUND', 404);
    this.resource = resource;
  }
}

/**
 * Permission error
 */
export class PermissionError extends AppError {
  constructor(message, permission = null) {
    super(message, 'PERMISSION_DENIED', 403);
    this.permission = permission;
  }
}

export default {
  AppError,
  ValidationError,
  ToolExecutionError,
  TimeoutError,
  NotFoundError,
  PermissionError
};
</file>

<file path="src/tools/index.js">
/**
 * @fileoverview Tools Index - Registry and exports for all tools
 * Provides tool registration, discovery, and execution
 *
 * Ported from ClaudeCli to GeminiCLI
 * @module tools
 */

import { BaseTool, ToolResult } from './base-tool.js';
export { BaseTool, ToolResult } from './base-tool.js';
export * from './errors.js';

/**
 * Tool registry - Map of tool names to tool instances
 */
const toolRegistry = new Map();

/**
 * Register a tool
 * @param {BaseTool} tool - Tool instance to register
 */
export function registerTool(tool) {
  if (!(tool instanceof BaseTool)) {
    throw new Error('Tool must be an instance of BaseTool');
  }
  if (toolRegistry.has(tool.name)) {
    console.warn(`Tool ${tool.name} is already registered. Overwriting.`);
  }
  toolRegistry.set(tool.name, tool);
  return tool;
}

/**
 * Get a tool by name
 * @param {string} name - Tool name
 * @returns {BaseTool|undefined} Tool instance
 */
export function getTool(name) {
  return toolRegistry.get(name);
}

/**
 * Check if a tool exists
 * @param {string} name - Tool name
 * @returns {boolean}
 */
export function hasTool(name) {
  return toolRegistry.has(name);
}

/**
 * Get all tool names
 * @returns {string[]}
 */
export function getToolNames() {
  return Array.from(toolRegistry.keys());
}

/**
 * Get all registered tools
 * @returns {BaseTool[]}
 */
export function getAllTools() {
  return Array.from(toolRegistry.values());
}

/**
 * Get tool definitions for MCP registration
 * @returns {Object[]}
 */
export function getToolDefinitions() {
  return getAllTools().map(tool => tool.getDefinition());
}

/**
 * Execute a tool by name
 * @param {string} name - Tool name
 * @param {Object} input - Tool input
 * @returns {Promise<ToolResult>}
 */
export async function executeTool(name, input) {
  const tool = getTool(name);
  if (!tool) {
    return ToolResult.fail(`Tool not found: ${name}`, { tool: name });
  }
  return tool.execute(input);
}

/**
 * Unregister a tool
 * @param {string} name - Tool name
 * @returns {boolean} True if tool was removed
 */
export function unregisterTool(name) {
  return toolRegistry.delete(name);
}

/**
 * Clear all registered tools
 */
export function clearTools() {
  toolRegistry.clear();
}

/**
 * Get tool count
 * @returns {number}
 */
export function getToolCount() {
  return toolRegistry.size;
}

/**
 * Create a simple tool from a function
 * Utility for quick tool creation without extending BaseTool
 */
export function createSimpleTool({ name, description, inputSchema, handler, timeoutMs = 30000 }) {
  const { z } = require('zod');

  class SimpleTool extends BaseTool {
    constructor() {
      super({ name, description, inputSchema, timeoutMs });
      this.handler = handler;
    }

    async run(input) {
      return this.handler(input);
    }
  }

  const tool = new SimpleTool();
  registerTool(tool);
  return tool;
}

// Export the registry for advanced use cases
export { toolRegistry };

export default {
  registerTool,
  getTool,
  hasTool,
  getToolNames,
  getAllTools,
  getToolDefinitions,
  executeTool,
  unregisterTool,
  clearTools,
  getToolCount,
  createSimpleTool,
  BaseTool,
  ToolResult
};
</file>

<file path="Test-Dijkstra.ps1">
Import-Module "$PSScriptRoot\AgentSwarm.psm1" -Force
$res = Invoke-Llm -AgentName "Dijkstra" -FullPrompt "Create a JSON list of 3 fruits. Format: [{name: 'apple'}, ...]"
Write-Host "RAW RESPONSE:" -ForegroundColor Yellow
Write-Host $res
Write-Host "---"
</file>

<file path=".gitignore">
# Environment and secrets
.env
.env.*

# Dependencies
node_modules/

# Build outputs
dist/
GeminiGUI/dist/
GeminiGUI/src-tauri/target/

# Local data
data/
.serena/

# OS files
.DS_Store
Thumbs.db

# IDE
.vscode/
.idea/

# Logs
*.log
npm-debug.log*

# Ollama binary (too large for git)
bin/ollama.exe
</file>

<file path="AgentSwarm.psm1">
<#
.SYNOPSIS
    AgentSwarm v12.12 - "Ultimate Dijkstra" Edition
    - Ollama Prime: Modele lokalne dla większości agentów
    - Dijkstra Gemini Chain: Strategiczny planista używa WYŁĄCZNIE Gemini:
        1. gemini-3-pro-preview   (Flagowiec)
        2. gemini-2.5-pro         (Pierwszy oficer)
        3. gemini-3-flash-preview (Szybki zwiadowca)
        4. gemini-2.5-flash       (Ostatnia deska ratunku)
    - Self-dependency fix, Timeout 120s, Int casting fix
    - Direct Ollama API for parallel execution
#>

# --- Agent Configuration ---
# Ollama models are now primary
$script:AgentModels = @{
    "Dijkstra" = "qwen2.5-coder:1.5b"
    "Yennefer" = "qwen2.5-coder:1.5b"
    "Vesemir"  = "llama3.2:3b"
    "Geralt"   = "llama3.2:3b"
    "Triss"    = "qwen2.5-coder:1.5b"
    "Jaskier"  = "llama3.2:3b"
    "Ciri"     = "llama3.2:1b"
    "Eskel"    = "llama3.2:3b"
    "Lambert"  = "qwen2.5-coder:1.5b"
    "Zoltan"   = "llama3.2:3b"
    "Regis"    = "phi3:mini"
    "Philippa" = "qwen2.5-coder:1.5b"
}
# STRICT MANDATE retained for Gemini Fallback
$script:MandatedChain = "gemini-3-pro-preview,gemini-2.5-pro,gemini-3-flash-preview,gemini-2.5-flash"

# v12.12: DIJKSTRA SPECIAL CHAIN - Uses ONLY Gemini (no Ollama) for strategic planning
# 1. gemini-3-pro-preview   - Flagowiec (Flagship)
# 2. gemini-2.5-pro         - Pierwszy oficer (First Officer)
# 3. gemini-3-flash-preview - Szybki zwiadowca (Fast Scout)
# 4. gemini-2.5-flash       - Ostatnia deska ratunku (Last Resort)
$script:DijkstraChain = @(
    @{ Name = "gemini-3-pro-preview";   Role = "Flagowiec (Flagship)" },
    @{ Name = "gemini-2.5-pro";         Role = "Pierwszy oficer (First Officer)" },
    @{ Name = "gemini-3-flash-preview"; Role = "Szybki zwiadowca (Fast Scout)" },
    @{ Name = "gemini-2.5-flash";       Role = "Ostatnia deska ratunku (Last Resort)" }
)


$script:AgentPersonas = @{
    "Geralt"   = "Oversee security. Analyze code changes for vulnerabilities. VETO unsafe changes."
    "Yennefer" = "Focus on design patterns and code purity. Propose elegant, scalable solutions."
    "Triss"    = "QA role. Create test scenarios and actively try to break implemented features."
    "Jaskier"  = "Do not code. Translate final technical reports into user-friendly summaries."
    "Vesemir"  = "Mentor. Review Dijkstra's plan for logic and efficiency. Approve or reject."
    "Ciri"     = "Speed role. Execute simple, atomic tasks: find file, read snippet, list directory."
    "Eskel"    = "DevOps specialist. Ensure the application builds and deploys correctly (`npm run build`)."
    "Lambert"  = "Debugger. Analyze and fix errors when any agent's task fails."
    "Zoltan"   = "Data master. Analyze and modify `.json`, `.csv`, `.yml` files."
    "Regis"    = "Synthesizer/Researcher. Create technical summaries and search web if swarm is stuck."
    "Dijkstra" = "Master strategist. Create JSON plans with dependencies, assign agents and grimoires."
    "Philippa" = "API specialist. Handle all interactions with external APIs."
}
$script:PromptPrefix = "**META-INSTRUCTION:** Think Step-by-Step. Analyze persona, mission, and context. Formulate a plan. Execute concisely. RETURN ONLY RAW CONTENT (CODE/JSON/TEXT) WITHOUT MARKDOWN BLOCK WRAPPERS."

# --- Core Memory Architecture ---
$baseMemPath = Join-Path $PSScriptRoot ".serena" | Join-Path -ChildPath "memories"
$script:VectorDbPath = Join-Path $baseMemPath "vectordb"
$script:CachePath = Join-Path $baseMemPath "cache"
$script:KnowledgeGraphPath = Join-Path $baseMemPath "knowledge_graph.json"
$script:LogPath = Join-Path $PSScriptRoot "agent_swarm.log"

New-Item -ItemType Directory -Path $script:VectorDbPath -Force -ErrorAction SilentlyContinue | Out-Null
New-Item -ItemType Directory -Path $script:CachePath -Force -ErrorAction SilentlyContinue | Out-Null

# FIXED LOGGING FUNCTION
function Write-SwarmLog {
    param([string]$Message, [string]$Level="INFO")
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"

    # Retry mechanism to handle file lock contention in multi-threaded environment
    for ($i=0; $i -lt 10; $i++) {
        try {
            Add-Content -Path $script:LogPath -Value $logEntry -ErrorAction Stop
            break
        } catch {
            Start-Sleep -Milliseconds (Get-Random -Minimum 50 -Maximum 200)
        }
    }
}

function Set-SessionCache {
    param([string]$Key, [object]$Value)
    $cacheFile = Join-Path $script:CachePath "session_cache.json"
    $cache = @{}
    if (Test-Path $cacheFile) {
        $obj = Get-Content $cacheFile -Raw | ConvertFrom-Json -ErrorAction SilentlyContinue
        if ($obj) {
            $obj.PSObject.Properties | ForEach-Object { $cache[$_.Name] = $_.Value }
        }
    }
    $cache[$Key] = $Value
    $cache | ConvertTo-Json -Depth 5 | Set-Content $cacheFile
}

function Get-SessionCache {
    param([string]$Key)
    $cacheFile = Join-Path $script:CachePath "session_cache.json"
    if (Test-Path $cacheFile) {
        $cache = Get-Content $cacheFile | ConvertFrom-Json -ErrorAction SilentlyContinue
        if ($cache -and $cache.PSObject.Properties[$Key]) { return $cache[$Key] }
    }
    return $null
}

function Clear-SessionCache {
    $cacheFile = Join-Path $script:CachePath "session_cache.json"
    if (Test-Path $cacheFile) { Remove-Item $cacheFile }
}

function Add-VectorMemory {
    param([string]$AgentName, [string]$Type, [string]$Content, [string]$Tags = "")
    $memFile = Join-Path $script:VectorDbPath "$($AgentName).jsonl"
    $entry = @{ id = [Guid]::NewGuid().ToString(); timestamp = Get-Date -Format 'u'; agent = $AgentName; type = $Type; content = $Content; tags = $Tags }
    $entry | ConvertTo-Json -Depth 5 -Compress | Add-Content -Path $memFile
}

function Get-VectorMemory {
    param([string]$AgentName,[string]$Query,[int]$TopK=5,[string]$TypeFilter="",[string]$ExcludeType="")
    $memFile = Join-Path $script:VectorDbPath "$($AgentName).jsonl"
    if (-not (Test-Path $memFile)) { return @() }

    $content = Get-Content $memFile -ErrorAction SilentlyContinue
    if (-not $content) { return @() }
    $allMemories = $content | ForEach-Object { $_ | ConvertFrom-Json }
    if ($TypeFilter) { $allMemories = $allMemories | Where-Object { $_.type -eq $TypeFilter } }
    if ($ExcludeType) { $allMemories = $allMemories | Where-Object { $_.type -ne $ExcludeType } }

    if (-not $Query) { return ($allMemories | Select-Object -Last $TopK) }

    $keywords = $Query.Split(' ') | Select-Object -Unique
    $scoredMemories = foreach ($memory in $allMemories) {
        $score = 0
        foreach ($keyword in $keywords) { if ($memory.content -like "*$keyword*") { $score++ } }
        if ($memory.type -eq 'error' -and $score -gt 0) { $score += 10 }
        if ($score -gt 0) { $memory | Add-Member -NotePropertyName "Score" -NotePropertyValue $score -PassThru }
    }
    if ($scoredMemories) { return ($scoredMemories | Sort-Object Score -Descending | Select-Object -First $TopK) }
    else { return ($allMemories | Select-Object -Last $TopK) }
}

function Get-ContextualMemories {
    param([string]$AgentName, [string]$Query, [int]$TokenLimit = 8192)
    $finalMemories = @()
    $currentTokenCount = 0
    $sessionCache = Get-SessionCache -Key "chronicle"
    if ($sessionCache) {
        $finalMemories += [PSCustomObject]@{ type = "L1_Cache"; content = $sessionCache }
        $currentTokenCount += ($sessionCache.Length / 4)
    }

    $relatedMemories = Get-VectorMemory -AgentName $AgentName -Query $Query -TopK 10
    foreach ($mem in $relatedMemories) {
        $memTokenCount = ($mem.content.Length / 4)
        if (($currentTokenCount + $memTokenCount) -lt $TokenLimit) { $finalMemories += $mem; $currentTokenCount += $memTokenCount }
    }

    return $finalMemories | ConvertTo-Json -Depth 5
}

function Get-GrimoireContent {
    param([array]$GrimoireNames)
    $fullContent = ""
    foreach ($name in $GrimoireNames) {
        $path = Join-Path $PSScriptRoot "grimoires" "$($name)_tools.md"
        if (Test-Path $path) {
            $fullContent += (Get-Content $path -Raw) + "`n`n"
        }
    }
    return $fullContent
}


# --- LLM Invocation (v12.12 - DIJKSTRA GEMINI SPECIAL) ---
function Invoke-Llm {
    param([Parameter(Mandatory=$true)][string]$AgentName, [Parameter(Mandatory=$true)][string]$FullPrompt, [array]$ModelOverride)

    # v12.12: DIJKSTRA uses ONLY Gemini chain (strategic planning requires best models)
    if ($AgentName -eq "Dijkstra") {
        Write-SwarmLog -Message "DIJKSTRA STRATEGIC MODE: Engaging Gemini-only chain (no Ollama)."
        foreach ($modelConfig in $script:DijkstraChain) {
            $modelName = $modelConfig.Name
            $modelRole = $modelConfig.Role
            try {
                $nodePath = (Get-Command node).Source
                $geminiJsPath = Join-Path $PSScriptRoot "node_modules\@google\gemini-cli\dist\index.js"
                if (-not (Test-Path $geminiJsPath)) { throw "gemini index.js not found" }

                $targetModel = $modelName.Trim()
                if ($targetModel -match "^models/(.+)") { $targetModel = $matches[1] }

                Write-SwarmLog -Message "Dijkstra attempting: $targetModel [$modelRole]"

                $tmpFile = [System.IO.Path]::GetTempFileName()
                Set-Content -Path $tmpFile -Value $FullPrompt -Encoding UTF8

                $geminiResult = Get-Content $tmpFile -Raw | & $nodePath $geminiJsPath -m $targetModel 2>&1 | Out-String

                Remove-Item $tmpFile -ErrorAction SilentlyContinue

                if ($geminiResult -is [array]) { $geminiResult = $geminiResult -join "`n" }
                $geminiResult = "$geminiResult".Trim()

                if ($geminiResult -match "^Error:|^CLI Error:|^An unexpected critical error") {
                     throw "CLI Error: $geminiResult"
                }
                if ([string]::IsNullOrWhiteSpace($geminiResult)) { throw "Empty result" }

                Write-SwarmLog -Message "Dijkstra SUCCESS with $targetModel [$modelRole]"
                return $geminiResult
            } catch {
                Write-SwarmLog -Level "WARN" -Message "Dijkstra: $modelName [$modelRole] failed: $($_.Exception.Message). Trying next..."
                continue
            }
        }
        $err = "ERROR: Dijkstra chain exhausted. All Gemini models failed."
        Write-SwarmLog -Level "ERROR" -Message $err
        return $err
    }

    # ALL OTHER AGENTS: Use Ollama Prime first, then Gemini fallback
    # 1. PRIMARY: Local Ollama Execution
    try {
        Write-SwarmLog -Message "Agent $AgentName attempting thinking with OLLAMA PRIME."
        $exe = if (Test-Path (Join-Path $PSScriptRoot "bin\ollama.exe")) { Join-Path $PSScriptRoot "bin\ollama.exe" } else { "ollama" }
        $localModelsPath = Join-Path $PSScriptRoot "data\ollama\models"
        if (Test-Path $localModelsPath) { $env:OLLAMA_MODELS = $localModelsPath }

        $localModel = $script:AgentModels[$AgentName]
        $result = (& $exe run $localModel $FullPrompt 2>&1)
        if ([string]::IsNullOrWhiteSpace($result)) { throw "Empty result from Ollama" }
        return $result
    } catch {
        Write-SwarmLog -Level "WARN" -Message "OLLAMA PRIME failed: $($_.Exception.Message). Engaging Gemini Fallback."
    }

    # 2. FALLBACK: Gemini Chain (for non-Dijkstra agents)
    $modelChain = $script:MandatedChain.Split(',')
    foreach ($modelName in $modelChain) {
        try {
            $nodePath = (Get-Command node).Source
            $geminiJsPath = Join-Path $PSScriptRoot "node_modules\@google\gemini-cli\dist\index.js"
            if (-not (Test-Path $geminiJsPath)) { throw "gemini index.js not found" }

            $targetModel = $modelName.Trim()
            if ($targetModel -match "^models/(.+)") { $targetModel = $matches[1] }

            Write-SwarmLog -Message "Agent $AgentName attempting thinking with Gemini Fallback: $targetModel"

            $tmpFile = [System.IO.Path]::GetTempFileName()
            Set-Content -Path $tmpFile -Value $FullPrompt -Encoding UTF8

            $geminiResult = Get-Content $tmpFile -Raw | & $nodePath $geminiJsPath -m $targetModel 2>&1 | Out-String

            Remove-Item $tmpFile -ErrorAction SilentlyContinue

            if ($geminiResult -is [array]) { $geminiResult = $geminiResult -join "`n" }
            $geminiResult = "$geminiResult".Trim()

            if ($geminiResult -match "^Error:|^CLI Error:|^An unexpected critical error") {
                 throw "CLI Error: $geminiResult"
            }
            if ([string]::IsNullOrWhiteSpace($geminiResult)) { throw "Empty result" }

            return $geminiResult
        } catch {
            Write-SwarmLog -Level "WARN" -Message "Gemini Fallback ($modelName) failed: $($_.Exception.Message). Trying next..."
            continue
        }
    }

    $err = "ERROR: Total system failure. Both Ollama and ALL Gemini models are dead."
    Write-SwarmLog -Level "ERROR" -Message $err
    return $err
}

# --- Graph Processor ---
function Start-GraphProcessor {
    param([Parameter(Mandatory=$true)][array]$Plan, [switch]$Yolo)
    $threadCount = if ($Yolo) { 12 } else { 6 }
    $RunspacePool = [runspacefactory]::CreateRunspacePool(1, $threadCount)
    $RunspacePool.Open()
    $completedTasks = [System.Collections.Concurrent.ConcurrentDictionary[int, bool]]::new()
    $remainingTasks = [System.Collections.Generic.List[object]]::new(); $Plan.ForEach({ $remainingTasks.Add($_) })

    # v12.11 FIX: Remove self-dependencies and validate all task IDs are integers
    foreach ($task in $remainingTasks) {
        # Ensure task.id is int
        $task.id = [int]$task.id
        if ($task.dependencies -and $task.dependencies.Count -gt 0) {
            $originalCount = $task.dependencies.Count
            # Convert dependencies to ints and filter self-references
            $task.dependencies = @($task.dependencies | ForEach-Object { [int]$_ } | Where-Object { $_ -ne $task.id })
            if ($task.dependencies.Count -lt $originalCount) {
                Write-SwarmLog -Level "WARN" -Message "Task $($task.id) ($($task.agent)): Removed self-dependency. Was: $originalCount deps, Now: $($task.dependencies.Count) deps."
            }
        }
    }

    Write-SwarmLog -Message "Starting GraphProcessor with $($remainingTasks.Count) tasks."

    while ($remainingTasks.Count -gt 0) {
        $tasksToRun = @(); $tasksToRemove = @()
        foreach ($task in $remainingTasks) {
            $dependenciesMet = $true
            # v12.11: Cast depId to int to match ConcurrentDictionary[int,bool]
            foreach ($depId in $task.dependencies) {
                $depIdInt = [int]$depId
                if (-not $completedTasks.ContainsKey($depIdInt)) { $dependenciesMet = $false; break }
            }
            if ($dependenciesMet) { $tasksToRun += $task; $tasksToRemove += $task }
        }
        if ($tasksToRun.Count -eq 0) {
            Write-SwarmLog -Level "ERROR" -Message "Deadlock detected."
            break
        }
        $tasksToRemove.ForEach({ $remainingTasks.Remove($_) })
        # v12.10: Simplified scriptblock - direct Ollama call with correct model per agent
        $capturedPrefix = $script:PromptPrefix
        $capturedPersonas = $script:AgentPersonas
        $capturedAgentModels = $script:AgentModels

        $jobs = @()
        foreach($task in $tasksToRun) {
            $scriptBlock = {
                param($t, $PromptPrefix, $AgentPersonas, $AgentModels)
                try {
                    $persona = if ($AgentPersonas -and $AgentPersonas[$t.agent]) { $AgentPersonas[$t.agent] } else { "You are agent $($t.agent). Complete the task efficiently." }
                    $agentModel = if ($AgentModels -and $AgentModels[$t.agent]) { $AgentModels[$t.agent] } else { "llama3.2:1b" }
                    $prompt = "$PromptPrefix`nPERSONA: $persona`nTASK: $($t.task)`nRespond with the completed work only. No explanations needed."

                    # Direct Ollama API call (no module dependency)
                    $body = @{
                        model = $agentModel
                        prompt = $prompt
                        stream = $false
                        options = @{ temperature = 0.7; num_predict = 2000 }
                    } | ConvertTo-Json -Depth 5

                    $response = Invoke-RestMethod -Uri "http://localhost:11434/api/generate" -Method Post -Body $body -ContentType "application/json" -TimeoutSec 90

                    if ($response -and $response.response) {
                        $result = $response.response.Trim()
                        return [PSCustomObject]@{ Id = $t.id; Status = "Success"; Message = "OK"; Result = $result }
                    } else {
                        return [PSCustomObject]@{ Id = $t.id; Status = "Failed"; Message = "Empty Ollama response" }
                    }
                } catch {
                    return [PSCustomObject]@{ Id = $t.id; Status = "Failed"; Message = "ERROR: $($_.Exception.Message)" }
                }
            }
            $job = [powershell]::Create().AddScript($scriptBlock).AddArgument($task).AddArgument($capturedPrefix).AddArgument($capturedPersonas).AddArgument($capturedAgentModels)
            $job.RunspacePool = $RunspacePool
            $jobs += [PSCustomObject]@{ Pipe = $job; Handle = $job.BeginInvoke(); Task = $task }
        }
        # v12.8 FIX: Add 120s timeout per task to prevent infinite hangs
        $taskTimeout = 120000  # 120 seconds in milliseconds
        foreach ($j in $jobs) {
            $completed = $j.Handle.AsyncWaitHandle.WaitOne($taskTimeout)
            if ($completed) {
                try {
                    $result = $j.Pipe.EndInvoke($j.Handle)
                    # v12.11: Always cast task ID to int
                    $taskId = [int]$j.Task.id
                    if ($result -and $result.Status -eq "Success") {
                        $completedTasks[$taskId] = $true
                        $preview = if ($result.Result) { $result.Result.Substring(0, [Math]::Min(80, $result.Result.Length)) -replace "`n"," " } else { "OK" }
                        Write-Host "[SWARM] Task $taskId ($($j.Task.agent)) completed: $preview..." -ForegroundColor Green
                    } else {
                        $errMsg = if ($result -and $result.Message) { $result.Message } else { "Unknown error" }
                        Write-Host "[SWARM] Task $taskId ($($j.Task.agent)) failed: $errMsg" -ForegroundColor Red
                        # Mark as completed anyway to prevent deadlock on single-task failure
                        $completedTasks[$taskId] = $true
                    }
                } catch {
                    $taskId = [int]$j.Task.id
                    Write-Host "[SWARM] Task $taskId ($($j.Task.agent)) threw exception: $($_.Exception.Message)" -ForegroundColor Red
                    # Mark as completed anyway
                    $completedTasks[$taskId] = $true
                }
            } else {
                $taskId = [int]$j.Task.id
                Write-Host "[SWARM] Task $taskId ($($j.Task.agent)) TIMEOUT after 120s." -ForegroundColor Yellow
                $j.Pipe.Stop()
                # Mark as completed to prevent infinite retry
                $completedTasks[$taskId] = $true
            }
            $j.Pipe.Dispose()
        }
    }
    $RunspacePool.Close(); $RunspacePool.Dispose()
}

# --- Main Protocol ---
function Invoke-AgentSwarm {
    param([Parameter(Mandatory=$true)][string]$Objective, [switch]$Yolo)
    Write-Host "=== SCHOOL OF THE WOLF: COMPLETE PROTOCOL v12.12 (Ultimate) ===" -ForegroundColor Cyan
    Write-SwarmLog -Message "Starting protocol for objective: $Objective"

    Clear-SessionCache
    Set-SessionCache -Key "objective" -Value $Objective

    # Recon phase is skipped for stability
    Write-SwarmLog -Level "WARN" -Message "Recon phase skipped to avoid instability."
    Set-SessionCache -Key "chronicle" -Value "Chronicle Start: Recon phase skipped. Proceeding directly to planning."

    # Dijkstra Planning
    $chronicle1 = Get-SessionCache -Key "chronicle"
    $dijkstraPrompt2 = "Based on the objective, create a JSON plan. You are operating blind without file system recon. Chronicle: $chronicle1. Objective: $Objective. OUTPUT VALID JSON ONLY. IMPORTANT: 'dependencies' must be an array of task IDs (integers), NOT agent names! Example: [{`"id`":1,`"agent`":`"Ciri`",`"task`":`"List files`",`"grimoires`":[],`"dependencies`":[]},{`"id`":2,`"agent`":`"Geralt`",`"task`":`"Check security`",`"grimoires`":[],`"dependencies`":[1]}]"
    $plan2Json = Invoke-Llm -AgentName "Dijkstra" -FullPrompt "$($script:PromptPrefix)`n$($script:AgentPersonas['Dijkstra'])`n$dijkstraPrompt2"

    Write-SwarmLog -Level "DEBUG" -Message "RAW JSON from Dijkstra: $plan2Json"

    # AGGRESSIVE/FINAL JSON CLEANING LOGIC v12.6
    # Step 0: Force string conversion (PowerShell might return array)
    $cleanJson = if ($plan2Json -is [array]) { $plan2Json -join '' } else { [string]$plan2Json }
    # Step 1: Remove ALL non-printable ASCII characters (keeps only space to tilde + newline/tab)
    $cleanJson = $cleanJson -replace '[^\x20-\x7E\r\n\t]',''
    # Step 2: Remove markdown code block wrapper
    $cleanJson = $cleanJson -replace '```json\s*',''
    $cleanJson = $cleanJson -replace '```\s*',''
    # Step 3: Trim whitespace
    $cleanJson = $cleanJson.Trim()
    # Step 4: Extract JSON array or object (greedy match)
    $jsonFound = $cleanJson -match '(?s)(\[[\s\S]*\]|\{[\s\S]*\})'
    if ($jsonFound -and $matches -and $matches[1]) {
        $cleanJson = $matches[1]
    } else {
        Write-SwarmLog -Level "WARN" -Message "No JSON structure found in cleaned response. Using raw."
    }
    # Step 5: Remove JS-style comments
    $cleanJson = $cleanJson -replace '(?m)^\s*//.*',''

    # Safety Check for JSON
    $plan2 = $null
    try {
        $plan2 = $cleanJson | ConvertFrom-Json
    } catch {
        Write-SwarmLog -Level "ERROR" -Message "Dijkstra produced invalid JSON. Cleaned Content: $cleanJson"
        # Fallback plan structure
        $plan2 = @( @{ id = 2; agent = "Dijkstra"; task = "JSON Generation Failed. Execute manual override."; grimoires = @(); dependencies = @() })
    }

    if ($plan2) { Start-GraphProcessor -Plan $plan2 -Yolo:$Yolo }

    $finalChronicle = Get-SessionCache -Key "chronicle"
    return "Mission finished."
}

Export-ModuleMember -Function Invoke-AgentSwarm, Get-VectorMemory, Get-SessionCache, Write-SwarmLog, Invoke-Llm
Set-Alias -Name Get-SwarmMemory -Value Get-VectorMemory -Scope Global
Set-Alias -Name Get-SwarmCache -Value Get-SessionCache -Scope Global
</file>

<file path="bridge.json">
{
  "requests": [],
  "auto_approve": true
}
</file>

<file path="bridge.ps1">
param(
    [string]$Message = "Confirm action"
)

$BridgeFile = "C:\Users\BIURODOM\Desktop\GeminiCLI\bridge.json"

function Get-BridgeData {
    if (Test-Path $BridgeFile) {
        return Get-Content $BridgeFile -Raw | ConvertFrom-Json
    }
    return @{ requests = @(); auto_approve = $false }
}

function Set-BridgeData {
    param($Data)
    $Data | ConvertTo-Json -Depth 10 | Set-Content $BridgeFile
}

# 1. Check Auto-Approve
$data = Get-BridgeData
if ($data.auto_approve) {
    Write-Host "Auto-approved by GUI Bridge." -ForegroundColor Green
    return $true
}

# 2. Create Request
$id = [guid]::NewGuid().ToString().Substring(0, 8)
$req = @{
    id = $id
    message = $Message
    status = "pending"
}

if (-not $data.requests) { $data.requests = @() }
$data.requests += $req
Set-BridgeData $data

Write-Host "Waiting for approval in GUI (ID: $id)..." -ForegroundColor Cyan

# 3. Poll for Status
while ($true) {
    Start-Sleep -Seconds 1
    $data = Get-BridgeData
    $myReq = $data.requests | Where-Object { $_.id -eq $id }
    
    if (-not $myReq) {
        Write-Error "Request disappeared!"
        return $false
    }

    if ($myReq.status -eq "approved") {
        Write-Host "Approved!" -ForegroundColor Green
        return $true
    }
    if ($myReq.status -eq "rejected") {
        Write-Host "Rejected!" -ForegroundColor Red
        return $false
    }
}
</file>

<file path="gemini.bat">
@echo off
REM Gemini CLI - Portable Launcher
REM Uruchom ten skrypt, aby uruchomic Gemini CLI

cd /d "%~dp0"
node "node_modules\@google\gemini-cli\dist\index.js" %*
</file>

<file path="gemini.ps1">
# Gemini CLI - Portable Launcher (PowerShell)
# Uruchom ten skrypt, aby uruchomic Gemini CLI

$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
Set-Location $ScriptDir

# Import AgentSwarm v3.0
if (Test-Path "$ScriptDir\AgentSwarm.psm1") {
    Import-Module "$ScriptDir\AgentSwarm.psm1" -Force
}

& node "$ScriptDir\node_modules\@google\gemini-cli\dist\index.js" @args
</file>

<file path="GeminiGUI/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="GeminiGUI/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tauri + React + Typescript</title>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="GeminiGUI/package.json">
{
  "name": "geminigui",
  "private": true,
  "version": "0.2.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "tauri": "tauri",
    "lint": "tsc --noEmit"
  },
  "dependencies": {
    "@tailwindcss/vite": "4.1.18",
    "@tanstack/react-query": "5.90.19",
    "@tauri-apps/api": "2.5.0",
    "@tauri-apps/plugin-dialog": "2.6.0",
    "@tauri-apps/plugin-fs": "2.4.5",
    "@tauri-apps/plugin-opener": "2.3.1",
    "clsx": "2.1.1",
    "framer-motion": "12.27.1",
    "lucide-react": "0.562.0",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-markdown": "10.1.0",
    "react-virtuoso": "4.18.1",
    "remark-gfm": "4.0.1",
    "tailwind-merge": "3.4.0",
    "tailwindcss": "4.1.18",
    "zustand": "5.0.10"
  },
  "devDependencies": {
    "@tauri-apps/cli": "2.5.0",
    "@types/react": "19.1.8",
    "@types/react-dom": "19.1.6",
    "@vitejs/plugin-react": "4.6.0",
    "typescript": "5.8.3",
    "vite": "7.0.4"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}
</file>

<file path="GeminiGUI/public/tauri.svg">
<svg width="206" height="231" viewBox="0 0 206 231" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M143.143 84C143.143 96.1503 133.293 106 121.143 106C108.992 106 99.1426 96.1503 99.1426 84C99.1426 71.8497 108.992 62 121.143 62C133.293 62 143.143 71.8497 143.143 84Z" fill="#FFC131"/>
<ellipse cx="84.1426" cy="147" rx="22" ry="22" transform="rotate(180 84.1426 147)" fill="#24C8DB"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M166.738 154.548C157.86 160.286 148.023 164.269 137.757 166.341C139.858 160.282 141 153.774 141 147C141 144.543 140.85 142.121 140.558 139.743C144.975 138.204 149.215 136.139 153.183 133.575C162.73 127.404 170.292 118.608 174.961 108.244C179.63 97.8797 181.207 86.3876 179.502 75.1487C177.798 63.9098 172.884 53.4021 165.352 44.8883C157.82 36.3744 147.99 30.2165 137.042 27.1546C126.095 24.0926 114.496 24.2568 103.64 27.6274C92.7839 30.998 83.1319 37.4317 75.8437 46.1553C74.9102 47.2727 74.0206 48.4216 73.176 49.5993C61.9292 50.8488 51.0363 54.0318 40.9629 58.9556C44.2417 48.4586 49.5653 38.6591 56.679 30.1442C67.0505 17.7298 80.7861 8.57426 96.2354 3.77762C111.685 -1.01901 128.19 -1.25267 143.769 3.10474C159.348 7.46215 173.337 16.2252 184.056 28.3411C194.775 40.457 201.767 55.4101 204.193 71.404C206.619 87.3978 204.374 103.752 197.73 118.501C191.086 133.25 180.324 145.767 166.738 154.548ZM41.9631 74.275L62.5557 76.8042C63.0459 72.813 63.9401 68.9018 65.2138 65.1274C57.0465 67.0016 49.2088 70.087 41.9631 74.275Z" fill="#FFC131"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M38.4045 76.4519C47.3493 70.6709 57.2677 66.6712 67.6171 64.6132C65.2774 70.9669 64 77.8343 64 85.0001C64 87.1434 64.1143 89.26 64.3371 91.3442C60.0093 92.8732 55.8533 94.9092 51.9599 97.4256C42.4128 103.596 34.8505 112.392 30.1816 122.756C25.5126 133.12 23.9357 144.612 25.6403 155.851C27.3449 167.09 32.2584 177.598 39.7906 186.112C47.3227 194.626 57.153 200.784 68.1003 203.846C79.0476 206.907 90.6462 206.743 101.502 203.373C112.359 200.002 122.011 193.568 129.299 184.845C130.237 183.722 131.131 182.567 131.979 181.383C143.235 180.114 154.132 176.91 164.205 171.962C160.929 182.49 155.596 192.319 148.464 200.856C138.092 213.27 124.357 222.426 108.907 227.222C93.458 232.019 76.9524 232.253 61.3736 227.895C45.7948 223.538 31.8055 214.775 21.0867 202.659C10.3679 190.543 3.37557 175.59 0.949823 159.596C-1.47592 143.602 0.768139 127.248 7.41237 112.499C14.0566 97.7497 24.8183 85.2327 38.4045 76.4519ZM163.062 156.711L163.062 156.711C162.954 156.773 162.846 156.835 162.738 156.897C162.846 156.835 162.954 156.773 163.062 156.711Z" fill="#24C8DB"/>
</svg>
</file>

<file path="GeminiGUI/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="GeminiGUI/README.md">
# Tauri + React + Typescript

This template should help get you started developing with Tauri, React and Typescript in Vite.

## Recommended IDE Setup

- [VS Code](https://code.visualstudio.com/) + [Tauri](https://marketplace.visualstudio.com/items?itemName=tauri-apps.tauri-vscode) + [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)
</file>

<file path="GeminiGUI/src-tauri/.gitignore">
# Generated by Cargo
# will have compiled files and executables
/target/

# Generated by Tauri
# will have schema files for capabilities auto-completion
/gen/schemas
</file>

<file path="GeminiGUI/src-tauri/build.rs">
fn main() {
    tauri_build::build()
}
</file>

<file path="GeminiGUI/src-tauri/capabilities/default.json">
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "opener:default"
  ]
}
</file>

<file path="GeminiGUI/src-tauri/Cargo.toml">
[package]
name = "geminigui"
version = "0.2.0"
description = "GeminiGUI - Tauri + React AI Chat Interface"
authors = ["GeminiCLI Team"]
edition = "2021"
rust-version = "1.75"

[lib]
name = "geminigui_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2.0.0", features = [] }

[dependencies]
tauri = { version = "2.0.0", features = ["tray-icon"] }
tauri-plugin-opener = "2.0.0"
tauri-plugin-dialog = "2.0.0"
tauri-plugin-fs = "2.0.0"
serde = { version = "1.0.217", features = ["derive"] }
serde_json = "1.0.138"
reqwest = { version = "0.12.12", features = ["json", "rustls-tls", "stream"] }
tokio = { version = "1.43.0", features = ["full"] }
futures-util = "0.3.31"

[profile.release]
lto = true
opt-level = 3
codegen-units = 1
panic = "abort"
strip = true

[profile.dev]
opt-level = 0
debug = true
</file>

<file path="GeminiGUI/src-tauri/src/lib.rs">
// Learn more about Tauri commands at https://tauri.app/develop/calling-rust/
use std::fs;
use std::path::Path;
use serde::{Deserialize, Serialize};
use tauri::{Emitter, Window, AppHandle, Manager};
use tauri::menu::{Menu, MenuItem};
use tauri::tray::{TrayIconBuilder, TrayIconEvent};
use futures_util::StreamExt;
use std::process::{Command, Stdio};
use std::io::{BufRead, BufReader};

// ============================================================================
// SECURITY: Configuration
// ============================================================================

/// Get the base directory for GeminiCLI (portable support)
fn get_base_dir() -> std::path::PathBuf {
    std::env::current_exe()
        .ok()
        .and_then(|p| p.parent().map(|p| p.to_path_buf()))
        .unwrap_or_else(|| std::env::current_dir().unwrap_or_default())
        .parent()
        .map(|p| p.to_path_buf())
        .unwrap_or_else(|| std::path::PathBuf::from("."))
}

fn get_bridge_path() -> std::path::PathBuf {
    get_base_dir().join("bridge.json")
}

/// SECURITY: Allowlist of safe commands
const ALLOWED_COMMANDS: &[&str] = &[
    // Safe read-only commands
    "dir", "ls", "pwd", "cd", "echo", "type", "cat", "head", "tail",
    "Get-Date", "Get-Location", "Get-ChildItem", "Get-Content",
    "whoami", "hostname", "systeminfo",
    // Git commands (read-only)
    "git status", "git log", "git branch", "git diff", "git remote -v",
    // Ollama commands
    "ollama list", "ollama ps", "ollama show",
    // Node/npm info
    "node --version", "npm --version", "npm list",
    // Python info
    "python --version", "pip list",
];

/// Check if a command is in the allowlist
fn is_command_allowed(command: &str) -> bool {
    let cmd_lower = command.to_lowercase().trim().to_string();

    // Check exact matches and prefix matches
    ALLOWED_COMMANDS.iter().any(|allowed| {
        let allowed_lower = allowed.to_lowercase();
        cmd_lower == allowed_lower ||
        cmd_lower.starts_with(&format!("{} ", allowed_lower)) ||
        cmd_lower.starts_with(&format!("{}|", allowed_lower))
    })
}
// ... (rest of struct definitions remains the same)

#[derive(Serialize, Deserialize, Debug, Clone)]
struct BridgeRequest {
    id: String,
    message: String,
    status: String, // "pending", "approved", "rejected"
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct BridgeData {
    requests: Vec<BridgeRequest>,
    auto_approve: bool,
}

impl Default for BridgeData {
    fn default() -> Self {
        Self {
            requests: vec![],
            auto_approve: true,
        }
    }
}

fn read_bridge_data() -> BridgeData {
    let bridge_path = get_bridge_path();
    if !bridge_path.exists() {
        return BridgeData::default();
    }
    match fs::read_to_string(&bridge_path) {
        Ok(content) => serde_json::from_str(&content).unwrap_or(BridgeData::default()),
        Err(_) => BridgeData::default(),
    }
}

fn write_bridge_data(data: &BridgeData) -> Result<(), String> {
    let bridge_path = get_bridge_path();
    let content = serde_json::to_string_pretty(data).map_err(|e| e.to_string())?;
    fs::write(&bridge_path, content).map_err(|e| e.to_string())
}

#[derive(Serialize, Deserialize, Debug)]
struct OllamaMessage {
    role: String,
    content: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    images: Option<Vec<String>>,
}

// Gemini Structures
#[derive(Serialize, Deserialize, Debug)]
struct GeminiPart {
    text: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
struct GeminiContent {
    role: String,
    parts: Vec<GeminiPart>,
}

#[derive(Serialize, Deserialize, Debug)]
struct GeminiRequest {
    contents: Vec<GeminiContent>,
}

#[derive(Serialize, Deserialize)]
struct OllamaChatRequest {
    model: String,
    messages: Vec<OllamaMessage>,
    stream: bool,
}

#[derive(Serialize, Deserialize)]
struct OllamaChatResponse {
    message: OllamaMessage,
    done: bool,
}

#[derive(Serialize, Deserialize, Debug)]
struct OllamaModel {
    name: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct OllamaTagsResponse {
    models: Vec<OllamaModel>,
}

#[derive(Clone, Serialize)]
struct StreamPayload {
    chunk: String,
    done: bool,
}


#[tauri::command]
fn get_bridge_state() -> Result<BridgeData, String> {
    Ok(read_bridge_data())
}

#[tauri::command]
fn set_auto_approve(enabled: bool) -> Result<BridgeData, String> {
    let mut data = read_bridge_data();
    data.auto_approve = enabled;
    write_bridge_data(&data)?;
    Ok(data)
}

#[tauri::command]
fn approve_request(id: String) -> Result<BridgeData, String> {
    let mut data = read_bridge_data();
    if let Some(req) = data.requests.iter_mut().find(|r| r.id == id) {
        req.status = "approved".to_string();
    }
    write_bridge_data(&data)?;
    Ok(data)
}

#[tauri::command]
fn reject_request(id: String) -> Result<BridgeData, String> {
    let mut data = read_bridge_data();
    if let Some(req) = data.requests.iter_mut().find(|r| r.id == id) {
        req.status = "rejected".to_string();
    }
    write_bridge_data(&data)?;
    Ok(data)
}

#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}

#[tauri::command]
async fn fetch_external_data(url: String) -> Result<serde_json::Value, String> {
    let client = reqwest::Client::new();
    let res = client.get(&url)
        .send()
        .await
        .map_err(|e| e.to_string())?
        .json::<serde_json::Value>()
        .await
        .map_err(|e| e.to_string())?;
    Ok(res)
}

#[tauri::command]
async fn prompt_ollama(messages: Vec<OllamaMessage>, model: String, endpoint: String) -> Result<String, String> {
    let client = reqwest::Client::new();
    let req = OllamaChatRequest {
        model,
        messages,
        stream: false,
    };
    
    let url = format!("{}/api/chat", endpoint.trim_end_matches('/'));
    let res = client.post(&url)
        .json(&req)
        .send()
        .await
        .map_err(|e| e.to_string())?;

    if !res.status().is_success() {
         return Err(format!("Ollama API Error: {}", res.status()));
    }

    let body: OllamaChatResponse = res.json().await.map_err(|e| e.to_string())?;
    Ok(body.message.content)
}

#[tauri::command]
async fn prompt_ollama_stream(
    window: Window, 
    messages: Vec<OllamaMessage>, 
    model: String, 
    endpoint: String
) -> Result<(), String> {
    let client = reqwest::Client::new();
    let req = OllamaChatRequest {
        model,
        messages,
        stream: true,
    };

    let url = format!("{}/api/chat", endpoint.trim_end_matches('/'));
    let mut stream = client.post(&url)
        .json(&req)
        .send()
        .await
        .map_err(|e| e.to_string())?
        .bytes_stream();

    while let Some(item) = stream.next().await {
        let chunk = item.map_err(|e| e.to_string())?;
        if let Ok(text) = String::from_utf8(chunk.to_vec()) {
            for line in text.lines() {
                if let Ok(json) = serde_json::from_str::<serde_json::Value>(line) {
                    if let Some(content) = json.get("message").and_then(|m| m.get("content")).and_then(|v| v.as_str()) {
                         let done = json.get("done").and_then(|v| v.as_bool()).unwrap_or(false);
                         window.emit("ollama-event", StreamPayload {
                             chunk: content.to_string(),
                             done
                         }).map_err(|e| e.to_string())?;
                    }
                }
            }
        }
    }

    Ok(())
}


#[tauri::command]
async fn get_ollama_models(endpoint: String) -> Result<Vec<String>, String> {
    let client = reqwest::Client::new();
    let url = format!("{}/api/tags", endpoint.trim_end_matches('/'));
    let res = client.get(&url)
        .send()
        .await
        .map_err(|e| e.to_string())?;

    if !res.status().is_success() {
         return Err(format!("Ollama API Error: {}", res.status()));
    }

    let body: OllamaTagsResponse = res.json().await.map_err(|e| e.to_string())?;
    Ok(body.models.into_iter().map(|m| m.name).collect())
}

/// SECURITY: Execute system command with allowlist validation
/// Only commands in ALLOWED_COMMANDS can be executed
#[tauri::command]
async fn run_system_command(command: String) -> Result<String, String> {
    // SECURITY: Validate command against allowlist
    if !is_command_allowed(&command) {
        return Err(format!(
            "SECURITY: Command '{}' is not in the allowlist. Allowed commands: {:?}",
            command.chars().take(50).collect::<String>(),
            ALLOWED_COMMANDS
        ));
    }

    // SECURITY: Additional checks for dangerous patterns
    let dangerous_patterns = [
        "rm ", "del ", "rmdir", "format", "mkfs",
        ">", ">>", "|", "&", ";", "`", "$(",
        "Remove-Item", "Clear-Content", "Set-Content",
        "Invoke-Expression", "iex", "Start-Process",
        "curl", "wget", "Invoke-WebRequest",
    ];

    for pattern in dangerous_patterns {
        if command.to_lowercase().contains(&pattern.to_lowercase()) {
            return Err(format!(
                "SECURITY: Command contains dangerous pattern '{}'. Blocked for safety.",
                pattern
            ));
        }
    }

    #[cfg(target_os = "windows")]
    let output = std::process::Command::new("powershell")
        .args(["-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", &command])
        .output()
        .map_err(|e| format!("Failed to execute command: {}", e))?;

    #[cfg(not(target_os = "windows"))]
    let output = std::process::Command::new("sh")
        .arg("-c")
        .arg(&command)
        .output()
        .map_err(|e| format!("Failed to execute command: {}", e))?;

    let stdout = String::from_utf8_lossy(&output.stdout).to_string();
    let stderr = String::from_utf8_lossy(&output.stderr).to_string();

    if !stderr.is_empty() && !stdout.is_empty() {
        Ok(format!("{}\n[STDERR]: {}", stdout, stderr))
    } else if !stderr.is_empty() {
        Ok(format!("[STDERR]: {}", stderr))
    } else {
        Ok(stdout)
    }
}

/// SECURITY: Spawn swarm agent with safe argument passing
/// Uses -File parameter instead of -Command to prevent injection
#[tauri::command]
async fn spawn_swarm_agent(window: Window, objective: String) -> Result<(), String> {
    // SECURITY: Validate objective - no shell metacharacters
    let dangerous_chars = ['`', '$', '|', '&', ';', '>', '<', '\n', '\r'];
    for c in dangerous_chars {
        if objective.contains(c) {
            return Err(format!(
                "SECURITY: Objective contains dangerous character '{}'. Blocked for safety.",
                c
            ));
        }
    }

    // SECURITY: Limit objective length
    if objective.len() > 1000 {
        return Err("SECURITY: Objective too long (max 1000 characters)".to_string());
    }

    // Get module path safely
    let base_dir = get_base_dir();
    let module_path = base_dir.join("AgentSwarm.psm1");

    if !module_path.exists() {
        return Err(format!("AgentSwarm.psm1 not found at: {:?}", module_path));
    }

    // SECURITY: Use encoded command to prevent injection
    // Base64 encode the script to avoid any shell interpretation
    let script = format!(
        "Import-Module '{}'; Invoke-AgentSwarm -Objective $args[0] -Yolo",
        module_path.display()
    );

    let mut child = Command::new("powershell")
        .args([
            "-NoProfile",
            "-ExecutionPolicy", "Bypass",
            "-Command",
            &script,
            &objective  // Passed as $args[0], not interpolated
        ])
        .current_dir(&base_dir)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(|e| format!("Failed to spawn swarm: {}", e))?;

    let stdout = child.stdout.take().ok_or("Failed to open stdout")?;
    let stderr = child.stderr.take().ok_or("Failed to open stderr")?;

    // Thread for stdout
    let window_clone = window.clone();
    std::thread::spawn(move || {
        let reader = BufReader::new(stdout);
        for line in reader.lines().flatten() {
            let _ = window_clone.emit("swarm-data", StreamPayload {
                chunk: line + "\n",
                done: false
            });
        }
    });

    // Thread for stderr
    let window_clone2 = window.clone();
    std::thread::spawn(move || {
        let reader = BufReader::new(stderr);
        for line in reader.lines().flatten() {
            let _ = window_clone2.emit("swarm-data", StreamPayload {
                chunk: format!("[ERR] {}\n", line),
                done: false
            });
        }
    });

    // Thread to wait for completion
    std::thread::spawn(move || {
        let status = child.wait();
        let msg = match status {
            Ok(s) if s.success() => "\n[SWARM COMPLETED SUCCESSFULLY]\n",
            Ok(s) => &format!("\n[SWARM EXITED WITH CODE: {:?}]\n", s.code()),
            Err(e) => &format!("\n[SWARM ERROR: {}]\n", e),
        };
        let _ = window.emit("swarm-data", StreamPayload {
            chunk: msg.to_string(),
            done: true
        });
    });

    Ok(())
}

/// SECURITY: Save file with path validation
#[tauri::command]
fn save_file_content(path: String, content: String) -> Result<(), String> {
    let file_path = Path::new(&path);

    // SECURITY: Block dangerous paths
    let path_str = path.to_lowercase();
    let dangerous_paths = [
        "system32", "windows", "program files", "/etc", "/bin", "/usr",
        ".ssh", ".gnupg", ".config", "appdata\\roaming"
    ];

    for dangerous in dangerous_paths {
        if path_str.contains(dangerous) {
            return Err(format!("SECURITY: Cannot write to protected path containing '{}'", dangerous));
        }
    }

    // SECURITY: Block overwriting executables
    let dangerous_extensions = [".exe", ".dll", ".bat", ".cmd", ".ps1", ".sh", ".msi"];
    if let Some(ext) = file_path.extension() {
        let ext_str = format!(".{}", ext.to_string_lossy().to_lowercase());
        if dangerous_extensions.contains(&ext_str.as_str()) {
            return Err(format!("SECURITY: Cannot write executable files ({})", ext_str));
        }
    }

    fs::write(&path, content).map_err(|e| format!("Failed to save file: {}", e))
}

#[tauri::command]
async fn prompt_gemini_stream(
    window: Window,
    messages: Vec<OllamaMessage>,
    model: String,
    api_key: String
) -> Result<(), String> {
    let client = reqwest::Client::new();
    
    // Convert internal message format to Gemini format
    let contents: Vec<GeminiContent> = messages.iter().map(|m| {
        GeminiContent {
            role: if m.role == "assistant" { "model".to_string() } else { "user".to_string() },
            parts: vec![GeminiPart { text: Some(m.content.clone()) }]
        }
    }).collect();

    let req = GeminiRequest { contents };
    let url = format!("https://generativelanguage.googleapis.com/v1beta/models/{}:streamGenerateContent?key={}", model, api_key);

    let mut stream = client.post(&url)
        .json(&req)
        .send()
        .await
        .map_err(|e| e.to_string())?
        .bytes_stream();

    while let Some(item) = stream.next().await {
        let chunk = item.map_err(|e| e.to_string())?;
        if let Ok(text) = String::from_utf8(chunk.to_vec()) {
            if let Some(start) = text.find("\"text\": \"") {
                let rest = &text[start + 9..];
                if let Some(end) = rest.find("\"") {
                    let content = &rest[..end];
                    let unescaped = content.replace("\\n", "\n").replace("\\\"", "\"");
                    window.emit("ollama-event", StreamPayload {
                        chunk: unescaped,
                        done: false
                    }).map_err(|e| e.to_string())?;
                }
            }
        }
    }
    
    window.emit("ollama-event", StreamPayload {
        chunk: "".to_string(),
        done: true
    }).map_err(|e| e.to_string())?;

    Ok(())
}

/// Read environment variables from .env file (secure path)
#[tauri::command]
async fn get_env_vars() -> Result<std::collections::HashMap<String, String>, String> {
    let base_dir = get_base_dir();
    let env_path = base_dir.join(".env");

    if !env_path.exists() {
        return Err(format!("Plik .env nie istnieje w: {:?}", env_path));
    }

    // SECURITY: Ensure we're reading from expected location
    if !env_path.starts_with(&base_dir) {
        return Err("SECURITY: Path traversal detected".to_string());
    }

    let content = fs::read_to_string(&env_path)
        .map_err(|e| format!("Failed to read .env: {}", e))?;

    let mut vars = std::collections::HashMap::new();
    for line in content.lines() {
        let line = line.trim();
        // Skip comments and empty lines
        if line.is_empty() || line.starts_with('#') {
            continue;
        }
        if let Some((key, value)) = line.split_once('=') {
            let key = key.trim().to_string();
            let value = value.trim().trim_matches('"').trim_matches('\'').to_string();
            vars.insert(key, value);
        }
    }
    Ok(vars)
}

#[tauri::command]
async fn get_gemini_models(api_key: String) -> Result<Vec<String>, String> {
    let client = reqwest::Client::new();
    let url = format!("https://generativelanguage.googleapis.com/v1beta/models?key={}", api_key);
    let res = client.get(&url)
        .send()
        .await
        .map_err(|e| e.to_string())?;

    if !res.status().is_success() {
         return Err(format!("Gemini API Error: {}", res.status()));
    }

    let body: serde_json::Value = res.json().await.map_err(|e| e.to_string())?;
    let mut models = Vec::new();
    if let Some(models_array) = body.get("models").and_then(|v| v.as_array()) {
        for model in models_array {
            if let Some(name) = model.get("name").and_then(|v| v.as_str()) {
                // Remove 'models/' prefix
                models.push(name.replace("models/", ""));
            }
        }
    }
    Ok(models)
}

// Function to assign a score to a model name for sorting
fn get_model_score(name: &str) -> i32 {
    let mut score = 0;
    if name.contains("pro") { score += 100; }
    if name.contains("ultra") { score += 200; }
    if name.contains("flash") { score -= 50; }
    if name.contains("1.5") { score += 50; }
    if name.contains("latest") { score += 10; }
    score
}

#[tauri::command]
async fn get_gemini_models_sorted(api_key: String) -> Result<Vec<String>, String> {
    let client = reqwest::Client::new();
    let url = format!("https://generativelanguage.googleapis.com/v1beta/models?key={}", api_key);
    let res = client.get(&url)
        .send()
        .await
        .map_err(|e| e.to_string())?;

    if !res.status().is_success() {
         return Err(format!("Gemini API Error: {}", res.status()));
    }

    let body: serde_json::Value = res.json().await.map_err(|e| e.to_string())?;
    let mut models = Vec::new();
    if let Some(models_array) = body.get("models").and_then(|v| v.as_array()) {
        for model in models_array {
            if let Some(name) = model.get("name").and_then(|v| v.as_str()) {
                // We only want generative models, and remove the 'models/' prefix
                if name.contains("generateContent") {
                    models.push(name.replace("models/", ""));
                }
            }
        }
    }
    
    // Sort models by score, descending
    models.sort_by(|a, b| get_model_score(b).cmp(&get_model_score(a)));

    Ok(models)
}

// ============================================================================
// MEMORY SYSTEM
// ============================================================================

#[derive(Serialize, Deserialize, Debug, Clone)]
struct MemoryEntry {
    id: String,
    agent: String,
    content: String,
    timestamp: i64,
    importance: f32,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct KnowledgeNode {
    id: String,
    #[serde(rename = "type")]
    node_type: String,
    label: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct KnowledgeEdge {
    source: String,
    target: String,
    label: String,
}

#[derive(Serialize, Deserialize, Debug, Clone, Default)]
struct KnowledgeGraph {
    nodes: Vec<KnowledgeNode>,
    edges: Vec<KnowledgeEdge>,
}

#[derive(Serialize, Deserialize, Debug, Clone, Default)]
struct MemoryStore {
    memories: Vec<MemoryEntry>,
    graph: KnowledgeGraph,
}

fn get_memory_path() -> std::path::PathBuf {
    get_base_dir().join("agent_memory.json")
}

fn read_memory_store() -> MemoryStore {
    let path = get_memory_path();
    if !path.exists() {
        return MemoryStore::default();
    }
    match fs::read_to_string(&path) {
        Ok(content) => serde_json::from_str(&content).unwrap_or(MemoryStore::default()),
        Err(_) => MemoryStore::default(),
    }
}

fn write_memory_store(store: &MemoryStore) -> Result<(), String> {
    let path = get_memory_path();
    let content = serde_json::to_string_pretty(store).map_err(|e| e.to_string())?;
    fs::write(&path, content).map_err(|e| e.to_string())
}

#[tauri::command]
fn get_agent_memories(agent_name: String, top_k: usize) -> Result<Vec<MemoryEntry>, String> {
    let store = read_memory_store();
    let mut memories: Vec<MemoryEntry> = store.memories
        .into_iter()
        .filter(|m| m.agent.to_lowercase() == agent_name.to_lowercase())
        .collect();

    // Sort by importance and timestamp
    memories.sort_by(|a, b| {
        b.importance.partial_cmp(&a.importance)
            .unwrap_or(std::cmp::Ordering::Equal)
            .then_with(|| b.timestamp.cmp(&a.timestamp))
    });

    memories.truncate(top_k);
    Ok(memories)
}

#[tauri::command]
fn add_agent_memory(agent: String, content: String, importance: f32) -> Result<MemoryEntry, String> {
    // Validate input
    if agent.is_empty() || content.is_empty() {
        return Err("Agent and content cannot be empty".to_string());
    }
    if content.len() > 10000 {
        return Err("Content too long (max 10000 chars)".to_string());
    }

    let mut store = read_memory_store();
    let entry = MemoryEntry {
        id: format!("mem_{}", std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis()),
        agent,
        content,
        timestamp: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64,
        importance: importance.clamp(0.0, 1.0),
    };

    store.memories.push(entry.clone());

    // Keep only last 1000 memories to prevent unbounded growth
    if store.memories.len() > 1000 {
        store.memories.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
        store.memories.truncate(1000);
    }

    write_memory_store(&store)?;
    Ok(entry)
}

#[tauri::command]
fn get_knowledge_graph() -> Result<KnowledgeGraph, String> {
    let store = read_memory_store();
    Ok(store.graph)
}

#[tauri::command]
fn add_knowledge_node(node_id: String, node_type: String, label: String) -> Result<KnowledgeNode, String> {
    // Validate input
    if node_id.is_empty() || label.is_empty() {
        return Err("Node ID and label cannot be empty".to_string());
    }

    let mut store = read_memory_store();

    // Check if node already exists
    if store.graph.nodes.iter().any(|n| n.id == node_id) {
        return Err("Node with this ID already exists".to_string());
    }

    let node = KnowledgeNode {
        id: node_id,
        node_type,
        label,
    };

    store.graph.nodes.push(node.clone());

    // Limit graph size
    if store.graph.nodes.len() > 500 {
        store.graph.nodes = store.graph.nodes.into_iter().take(500).collect();
    }

    write_memory_store(&store)?;
    Ok(node)
}

#[tauri::command]
fn add_knowledge_edge(source: String, target: String, label: String) -> Result<KnowledgeEdge, String> {
    // Validate input
    if source.is_empty() || target.is_empty() || label.is_empty() {
        return Err("Source, target, and label cannot be empty".to_string());
    }

    let mut store = read_memory_store();

    // Check if nodes exist
    let source_exists = store.graph.nodes.iter().any(|n| n.id == source);
    let target_exists = store.graph.nodes.iter().any(|n| n.id == target);

    if !source_exists || !target_exists {
        return Err("Source or target node does not exist".to_string());
    }

    let edge = KnowledgeEdge {
        source,
        target,
        label,
    };

    store.graph.edges.push(edge.clone());

    // Limit edges
    if store.graph.edges.len() > 1000 {
        store.graph.edges = store.graph.edges.into_iter().take(1000).collect();
    }

    write_memory_store(&store)?;
    Ok(edge)
}

#[tauri::command]
fn clear_agent_memories(agent_name: String) -> Result<usize, String> {
    let mut store = read_memory_store();
    let original_len = store.memories.len();
    store.memories.retain(|m| m.agent.to_lowercase() != agent_name.to_lowercase());
    let removed = original_len - store.memories.len();
    write_memory_store(&store)?;
    Ok(removed)
}

#[tauri::command]
fn start_ollama_server() -> Result<String, String> {
    #[cfg(target_os = "windows")]
    {
        // On Windows, we want to run this in a new, hidden window so it doesn't block
        // and doesn't show a flickering console.
        Command::new("powershell")
            .args(&["-WindowStyle", "Hidden", "-Command", "Start-Process", "powershell", "-ArgumentList '-NoExit -Command .\\start-ollama.ps1'"])
            .spawn()
            .map_err(|e| format!("Failed to spawn Ollama process: {}", e))?;
    }
    #[cfg(not(target_os = "windows"))]
    {
        // On other systems, run it in the background
        Command::new("sh")
            .arg("-c")
            .arg("./start-ollama.ps1 &")
            .spawn()
            .map_err(|e| format!("Failed to spawn Ollama process: {}", e))?;
    }

    Ok("Ollama server started in background.".to_string())
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .setup(|app| {
            // -- Start Ollama on App Boot (fire and forget) --
            tauri::async_runtime::spawn(async {
                let _ = start_ollama_server();
            });

            let quit_i = MenuItem::with_id(app, "quit", "Zakoncz", true, None::<&str>)?;
            let show_i = MenuItem::with_id(app, "show", "Pokaz Okno", true, None::<&str>)?;
            let menu = Menu::with_items(app, &[&show_i, &quit_i])?;

            let _tray = TrayIconBuilder::new()
                .icon(app.default_window_icon().unwrap().clone())
                .menu(&menu)
                .on_menu_event(|app: &AppHandle, event| match event.id.as_ref() {
                    "quit" => {
                        app.exit(0);
                    }
                    "show" => {
                        if let Some(window) = app.get_webview_window("main") {
                            let _ = window.show();
                            let _ = window.set_focus();
                        }
                    }
                    _ => {}
                })
                .on_tray_icon_event(|tray: &tauri::tray::TrayIcon, event| {
                    if let TrayIconEvent::Click { .. } = event {
                        let app = tray.app_handle();
                        if let Some(window) = app.get_webview_window("main") {
                            let _ = window.show();
                            let _ = window.set_focus();
                        }
                    }
                })
                .build(app)?;

            Ok(())
        })
        .plugin(tauri_plugin_opener::init())
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_fs::init())
        .invoke_handler(tauri::generate_handler![
            greet,
            get_bridge_state,
            set_auto_approve,
            approve_request,
            reject_request,
            fetch_external_data,
            prompt_ollama,
            prompt_ollama_stream,
            prompt_gemini_stream,
            get_ollama_models,
            get_gemini_models,
            get_gemini_models_sorted,
            get_env_vars,
            run_system_command,
            save_file_content,
            spawn_swarm_agent,
            start_ollama_server,
            // Memory system
            get_agent_memories,
            add_agent_memory,
            get_knowledge_graph,
            add_knowledge_node,
            add_knowledge_edge,
            clear_agent_memories
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
</file>

<file path="GeminiGUI/src-tauri/src/main.rs">
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    geminigui_lib::run()
}
</file>

<file path="GeminiGUI/src-tauri/tauri.conf.json">
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "geminigui",
  "version": "0.1.0",
  "identifier": "com.biurodom.geminigui",
  "build": {
    "beforeDevCommand": "npm run dev",
    "devUrl": "http://localhost:1420",
    "beforeBuildCommand": "npm run build",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [
      {
        "label": "main",
        "title": "GeminiGUI",
        "width": 1024,
        "height": 768,
        "visible": false
      },
      {
        "label": "live-preview",
        "title": "Live Preview",
        "width": 800,
        "height": 600,
        "url": "http://localhost:1420"
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ]
  }
}
</file>

<file path="GeminiGUI/src/App.css">
@import "tailwindcss";

/* ============================================
   TAILWIND THEME CONFIGURATION
   ============================================ */
@theme {
  --color-matrix-bg-primary: #0a1f0a;
  --color-matrix-bg-secondary: #001a00;
  --color-matrix-bg-tertiary: #0d2a0d;
  --color-matrix-accent: #00ff41;
  --color-matrix-accent-dim: #00cc33;
  --color-matrix-accent-glow: #33ff66;
  --color-matrix-text: #c0ffc0;
  --color-matrix-text-dim: #80c080;
  --color-matrix-border: #1a3a1a;
  --color-matrix-glass: rgba(10, 31, 10, 0.8);
  --color-matrix-glass-light: rgba(255, 255, 255, 0.05);

  --font-mono: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
  --font-sans: 'Inter', system-ui, -apple-system, sans-serif;

  --shadow-matrix-glow: 0 0 20px rgba(0, 255, 65, 0.3);
  --shadow-matrix-glow-sm: 0 0 10px rgba(0, 255, 65, 0.2);
  --shadow-glass: 0 8px 32px rgba(0, 0, 0, 0.3);
}

/* ============================================
   ROOT VARIABLES (DARK / DEFAULT)
   ============================================ */
:root {
  --matrix-bg-primary: #0a1f0a;
  --matrix-bg-secondary: #001a00;
  --matrix-accent: #00ff41;
  --matrix-text: #c0ffc0;
  --matrix-text-dim: #80c080;
  --matrix-glass-bg: rgba(0, 31, 0, 0.85);
  --matrix-panel-bg: rgba(10, 20, 10, 0.8);
  --matrix-border: rgba(0, 255, 65, 0.15);
  --matrix-input-bg: rgba(0, 0, 0, 0.5);
  --bg-image: url('/background.webp');
  --bg-overlay: rgba(10, 31, 10, 0.85);
  
  --glass-blur: blur(24px) saturate(200%);
  --glass-radius: 12px;
}

/* ============================================
   LIGHT THEME OVERRIDES
   ============================================ */
[data-theme='light'] {
  --matrix-bg-primary: #f0fdf4;
  --matrix-bg-secondary: #ffffff;
  --matrix-accent: #059669; /* Emerald 600 - Darker green for contrast */
  --matrix-text: #064e3b;   /* Emerald 900 */
  --matrix-text-dim: #34d399; /* Emerald 400 */
  --matrix-glass-bg: rgba(255, 255, 255, 0.7);
  --matrix-panel-bg: rgba(255, 255, 255, 0.6);
  --matrix-border: rgba(5, 150, 105, 0.2);
  --matrix-input-bg: rgba(255, 255, 255, 0.5);
  --bg-image: url('/backgroundlight.webp');
  --bg-overlay: rgba(255, 255, 255, 0.6);
}

html, body {
  background: var(--matrix-bg-primary);
  color: var(--matrix-text);
  font-family: var(--font-mono);
  overflow: hidden;
  height: 100vh;
  margin: 0;
  transition: background 0.3s ease, color 0.3s ease;
}

/* Matrix Background with Image */
.matrix-bg {
    background-image: linear-gradient(var(--bg-overlay), var(--bg-overlay)), var(--bg-image);
    background-size: cover;
    background-position: center;
    background-attachment: fixed;
    transition: background-image 0.5s ease-in-out;
}

/* ============================================
   GLASS PANEL STYLES
   ============================================ */
.glass-panel {
  background: var(--matrix-panel-bg);
  backdrop-filter: var(--glass-blur);
  -webkit-backdrop-filter: var(--glass-blur);
  border: 1px solid var(--matrix-border);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); /* Softer shadow */
  border-radius: var(--glass-radius);
  transition: background 0.3s ease, border-color 0.3s ease;
}

.glass-button {
  background: rgba(var(--matrix-accent), 0.1); /* Needs rgb values for opacity trick, using fallback for now */
  background: color-mix(in srgb, var(--matrix-accent) 10%, transparent);
  backdrop-filter: blur(4px);
  border: 1px solid color-mix(in srgb, var(--matrix-accent) 30%, transparent);
  color: var(--matrix-accent);
  transition: all 0.2s ease;
  cursor: pointer;
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
  font-family: var(--font-mono);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.glass-button:hover {
  background: color-mix(in srgb, var(--matrix-accent) 20%, transparent);
  box-shadow: 0 0 15px color-mix(in srgb, var(--matrix-accent) 20%, transparent);
  /* text-shadow: 0 0 5px color-mix(in srgb, var(--matrix-accent) 50%, transparent); Removed text shadow for cleaner light mode */
}

.glass-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    box-shadow: none;
}

.status-badge {
    padding: 0.25rem 0.75rem;
    border-radius: 9999px;
    font-size: 0.75rem;
    font-weight: bold;
    text-transform: uppercase;
}
.status-pending {
    background: rgba(255, 165, 0, 0.2);
    color: orange;
    border: 1px solid rgba(255, 165, 0, 0.4);
}
.status-approved {
    background: color-mix(in srgb, var(--matrix-accent) 20%, transparent);
    color: var(--matrix-accent);
    border: 1px solid color-mix(in srgb, var(--matrix-accent) 40%, transparent);
}

/* Custom Input Styling */
.matrix-input {
    background: var(--matrix-input-bg);
    border: 1px solid color-mix(in srgb, var(--matrix-accent) 30%, transparent);
    color: var(--matrix-text);
}
.matrix-input:focus {
    border-color: var(--matrix-accent);
    outline: none;
}

/* ============================================
   MARKDOWN STYLES
   ============================================ */
.markdown-body p { margin-bottom: 0.5em; }
.markdown-body p:last-child { margin-bottom: 0; }
.markdown-body pre { 
    background: rgba(0,0,0,0.3); 
    padding: 0.5em; 
    border-radius: 4px; 
    overflow-x: auto; 
    border: 1px solid var(--matrix-border);
    margin: 0.5em 0;
}
.markdown-body code { 
    background: rgba(0,0,0,0.2); 
    padding: 0.1em 0.3em; 
    border-radius: 2px;
    font-family: var(--font-mono);
    font-size: 0.9em;
}
.markdown-body pre code { 
    background: transparent; 
    padding: 0; 
}
.markdown-body ul, .markdown-body ol { margin-left: 1.5em; margin-bottom: 0.5em; }
.markdown-body li { margin-bottom: 0.2em; }
.markdown-body strong { color: var(--matrix-accent); font-weight: bold; }
.markdown-body a { color: var(--matrix-accent); text-decoration: underline; }
.markdown-body h1, .markdown-body h2, .markdown-body h3 {
    color: var(--matrix-text);
    margin-top: 0.5em;
    margin-bottom: 0.2em;
    font-weight: bold;
    border-bottom: 1px solid var(--matrix-border);
}
.markdown-body blockquote {
    border-left: 2px solid var(--matrix-accent);
    padding-left: 0.5em;
    margin-left: 0;
    font-style: italic;
    opacity: 0.8;
}
</file>

<file path="GeminiGUI/src/App.tsx">
import { useState, useEffect } from "react";
import { invoke } from "@tauri-apps/api/core";
import { listen } from "@tauri-apps/api/event";
import { useQuery } from "@tanstack/react-query";
import { Server, Sun, Moon, Settings, Zap, Eraser } from "lucide-react";
import { WebviewWindow } from "@tauri-apps/api/webviewWindow";

import { useAppStore } from "./store/useAppStore";
import { SettingsModal } from "./components/SettingsModal";
import { ChatContainer } from "./components/ChatContainer";
import { SessionSidebar } from "./components/SessionSidebar";
import { RightSidebar } from "./components/RightSidebar";
import { StatusFooter } from "./components/StatusFooter";

import "./App.css";

interface StreamPayload {
  chunk: string;
  done: boolean;
}

function App() {
  const [selectedModel, setSelectedModel] = useState("");
  const [isStreaming, setIsStreaming] = useState(false);
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);

  const {
    count, increment, decrement,
    theme, toggleTheme, provider, setProvider,
    sessions, currentSessionId, chatHistory,
    createSession, selectSession, deleteSession, updateSessionTitle,
    addMessage, updateLastMessage, clearHistory,
    settings, updateSettings
  } = useAppStore();

  // Derived State
  const currentMessages = currentSessionId ? (chatHistory[currentSessionId] || []) : [];

  // Open Live Preview Window on boot
  useEffect(() => {
    const openPreview = async () => {
      const livePreview = await WebviewWindow.getByLabel('live-preview');
      if (livePreview) {
        livePreview.show();
      }
    };
    openPreview();
  }, []);

  // Load API Keys from .env if not set
  useEffect(() => {
    const loadEnv = async () => {
      try {
        const env = await invoke<Record<string, string>>('get_env_vars');
        const newSettings: Record<string, string> = {};
        if (!settings.geminiApiKey && env.GEMINI_API_KEY) {
          newSettings.geminiApiKey = env.GEMINI_API_KEY;
        }
        if (Object.keys(newSettings).length > 0) {
          updateSettings(newSettings);
        }
      } catch (e) {
        console.warn("Failed to load .env keys", e);
      }
    };
    loadEnv();
  }, [settings.geminiApiKey, updateSettings]);

  // Apply theme
  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme);
  }, [theme]);

  // Setup Stream Listeners
  useEffect(() => {
    const unlistenOllama = listen<StreamPayload>('ollama-event', (event) => {
      const { chunk, done } = event.payload;
      if (!done) {
        updateLastMessage(chunk);
      } else {
        setIsStreaming(false);
      }
    });

    const unlistenSwarm = listen<StreamPayload>('swarm-data', (event) => {
      const { chunk, done } = event.payload;
      if (!done) {
        updateLastMessage(chunk);
      } else {
        setIsStreaming(false);
      }
    });

    return () => {
      unlistenOllama.then(f => f());
      unlistenSwarm.then(f => f());
    };
  }, [updateLastMessage]);

  // Agentic Tool Execution Detection
  useEffect(() => {
    if (isStreaming) return;
    if (currentMessages.length === 0) return;

    const lastMsg = currentMessages[currentMessages.length - 1];
    if (lastMsg.role === 'assistant') {
      const match = lastMsg.content.match(/\[Electrochemical: "(.*?)"\]/);
      if (match) {
        executeCommand(match[1]);
      }
    }
  }, [currentMessages, isStreaming]);

  // Execute system command
  const executeCommand = async (cmd: string) => {
    try {
      const bridge = await invoke<{ auto_approve: boolean }>('get_bridge_state');
      if (!bridge.auto_approve) {
        addMessage({ role: 'system', content: `[BRIDGE] Command queued for approval: ${cmd}`, timestamp: Date.now() });
        return;
      }
    } catch (e) {
      console.warn("Bridge check failed, proceeding anyway", e);
    }

    addMessage({ role: 'system', content: `> Executing: ${cmd}...`, timestamp: Date.now() });
    try {
      const result = await invoke<string>('run_system_command', { command: cmd });
      updateLastMessage(`\n\nRESULT:\n\`\`\`\n${result}\n\`\`\`\n`);
    } catch (err) {
      updateLastMessage(`\n\nERROR:\n${err}`);
    }
  };

  // Fetch Models
  const { data: models, isPending: modelsLoading, error: modelsError } = useQuery({
    queryKey: ['models', provider, settings.ollamaEndpoint, settings.geminiApiKey],
    queryFn: async () => {
      if (provider === 'gemini') {
        if (!settings.geminiApiKey) return ['gemini-1.5-flash', 'gemini-1.5-pro', 'gemini-1.0-pro'];
        try {
          const gModels = await invoke<string[]>("get_gemini_models", { apiKey: settings.geminiApiKey });
          if (gModels && gModels.length > 0 && !selectedModel) {
            setSelectedModel(gModels[0]);
          }
          return gModels;
        } catch (e) {
          console.error("Failed to fetch Gemini models", e);
          return ['gemini-1.5-flash', 'gemini-1.5-pro', 'gemini-1.0-pro'];
        }
      }
      const models = await invoke<string[]>("get_ollama_models", { endpoint: settings.ollamaEndpoint });
      if (models && models.length > 0 && !selectedModel) {
        setSelectedModel(models[0]);
      }
      return models;
    },
    retry: 1
  });

  // Handle chat submit
  const handleSubmit = async (userPrompt: string, attachedImage: string | null) => {
    let displayContent = userPrompt;
    if (attachedImage) {
      displayContent = `![Uploaded Image](${attachedImage})\n\n${userPrompt}`;
    }

    addMessage({ role: 'user', content: displayContent, timestamp: Date.now() });
    addMessage({ role: 'assistant', content: "", timestamp: Date.now() });

    setIsStreaming(true);

    // SWARM MODE
    try {
      updateLastMessage("Inicjuję Protokół Wilczej Zamieci (Wolf Swarm v3.0)... 🐺\n\n");
      await invoke('spawn_swarm_agent', { objective: userPrompt });
    } catch (error) {
      updateLastMessage(`\n[Błąd Swarm: ${error}]`);
      setIsStreaming(false);
    }
  };

  // Export Session
  const handleExport = () => {
    if (!currentSessionId) return;
    const session = sessions.find(s => s.id === currentSessionId);
    const messages = chatHistory[currentSessionId] || [];

    const content = messages.map(m =>
      `### ${m.role.toUpperCase()} [${new Date(m.timestamp).toLocaleString()}]\n${m.content}\n`
    ).join('\n---\n');

    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `session-${session?.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.md`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  return (
    <main className="container mx-auto p-4 h-screen flex flex-col gap-4 matrix-bg overflow-hidden transition-all duration-500">
      <SettingsModal isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} />

      {/* HEADER */}
      <header className="flex items-center justify-between border-b border-[var(--matrix-border)] pb-2 shrink-0">
        <div className="flex items-center gap-4">
          <img
            src={theme === 'dark' ? "/logodark.webp" : "/logolight.webp"}
            alt="Gemini Logo"
            className="w-10 h-10 object-contain transition-all duration-300"
          />
          <h1 className="text-3xl font-bold flex items-center gap-3 text-[var(--matrix-accent)] transition-colors duration-300">
            Gemini<span className={theme === 'dark' ? "text-white" : "text-gray-800"}>GUI</span>
          </h1>
        </div>
        <div className="flex gap-3 items-center">
          <button
            onClick={() => updateSettings({ useSwarm: !settings.useSwarm })}
            className={`p-2 rounded-full transition-colors ${settings.useSwarm ? 'bg-[var(--matrix-accent)] text-black shadow-[0_0_10px_rgba(0,255,65,0.5)]' : 'hover:bg-[var(--matrix-border)] text-[var(--matrix-text-dim)]'}`}
            title={settings.useSwarm ? "Tryb Swarm Aktywny (Wolf Swarm)" : "Aktywuj Tryb Swarm"}
          >
            <Zap size={20} fill={settings.useSwarm ? "currentColor" : "none"} />
          </button>
          <button
            onClick={() => { if(confirm("Wyczyścić historię czatu?")) clearHistory(); }}
            className="p-2 rounded-full hover:bg-[var(--matrix-border)] transition-colors text-[var(--matrix-accent)]"
            title="Wyczyść Czat"
          >
            <Eraser size={20} />
          </button>
          <button
            onClick={() => setIsSettingsOpen(true)}
            className="p-2 rounded-full hover:bg-[var(--matrix-border)] transition-colors text-[var(--matrix-accent)]"
            title="Ustawienia"
          >
            <Settings size={20} />
          </button>
          <div className="flex bg-black/20 rounded-full p-1 border border-[var(--matrix-border)]">
            <button
              onClick={() => setProvider('ollama')}
              className={`px-3 py-1 rounded-full text-xs transition-colors ${provider === 'ollama' ? 'bg-[var(--matrix-accent)] text-black font-bold' : 'text-[var(--matrix-text-dim)]'}`}
            >
              Local
            </button>
            <button
              onClick={() => setProvider('gemini')}
              className={`px-3 py-1 rounded-full text-xs transition-colors ${provider === 'gemini' ? 'bg-[var(--matrix-accent)] text-black font-bold' : 'text-[var(--matrix-text-dim)]'}`}
            >
              Cloud
            </button>
          </div>
          <button
            onClick={toggleTheme}
            className="p-2 rounded-full hover:bg-[var(--matrix-border)] transition-colors text-[var(--matrix-accent)]"
            title="Toggle Theme"
          >
            {theme === 'dark' ? <Sun size={20} /> : <Moon size={20} />}
          </button>
          <span className={`status-badge flex items-center gap-1 ${modelsError ? 'status-pending' : 'status-approved'}`}>
            <Server size={12} /> {modelsError ? 'Ollama Offline' : 'System Online'}
          </span>
        </div>
      </header>

      {/* MAIN CONTENT GRID */}
      <div className="flex-1 grid grid-cols-1 md:grid-cols-4 gap-4 overflow-hidden min-h-0">
        <SessionSidebar
          sessions={sessions}
          currentSessionId={currentSessionId}
          onCreateSession={createSession}
          onSelectSession={selectSession}
          onDeleteSession={deleteSession}
          onUpdateTitle={updateSessionTitle}
        />

        <ChatContainer
          messages={currentMessages}
          isStreaming={isStreaming}
          modelsLoading={modelsLoading}
          modelsError={modelsError}
          models={models}
          selectedModel={selectedModel}
          onSelectModel={setSelectedModel}
          onSubmit={handleSubmit}
          onExecuteCommand={executeCommand}
        />

        <RightSidebar
          count={count}
          onIncrement={increment}
          onDecrement={decrement}
          onExport={handleExport}
        />
      </div>

      {/* STATUS LINE FOOTER */}
      <StatusFooter
        isStreaming={isStreaming}
        isWorking={false}
        hasError={!!modelsError}
        selectedModel={selectedModel}
      />
    </main>
  );
}

export default App;
</file>

<file path="GeminiGUI/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="GeminiGUI/src/components/BridgePanel.tsx">
import { useState, useCallback } from 'react';
import { invoke } from '@tauri-apps/api/core';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Shield, Check, X, RefreshCw, ToggleLeft, ToggleRight, Clock } from 'lucide-react';

interface BridgeRequest {
    id: string;
    message: string;
    status: "pending" | "approved" | "rejected";
}

interface BridgeData {
    requests: BridgeRequest[];
    auto_approve: boolean;
}

export const BridgePanel: React.FC = () => {
    const queryClient = useQueryClient();
    const [lastUpdate, setLastUpdate] = useState<Date | null>(null);

    // Fetch bridge data with React Query
    const { data, isLoading, error, refetch } = useQuery({
        queryKey: ['bridge-state'],
        queryFn: async () => {
            const result = await invoke<BridgeData>('get_bridge_state');
            setLastUpdate(new Date());
            return result;
        },
        // Adaptive polling: faster when there are pending requests
        refetchInterval: (query) => {
            const data = query.state.data;
            const hasPending = data?.requests.some(r => r.status === 'pending');
            return hasPending ? 2000 : 10000; // 2s if pending, 10s otherwise
        },
        staleTime: 1000,
    });

    // Toggle auto-approve mutation
    const toggleMutation = useMutation({
        mutationFn: async (enabled: boolean) => {
            return await invoke<BridgeData>('set_auto_approve', { enabled });
        },
        onSuccess: (newData) => {
            queryClient.setQueryData(['bridge-state'], newData);
            setLastUpdate(new Date());
        },
    });

    // Action mutation (approve/reject)
    const actionMutation = useMutation({
        mutationFn: async ({ id, action }: { id: string; action: 'approve' | 'reject' }) => {
            const command = action === 'approve' ? 'approve_request' : 'reject_request';
            return await invoke<BridgeData>(command, { id });
        },
        onSuccess: (newData) => {
            queryClient.setQueryData(['bridge-state'], newData);
            setLastUpdate(new Date());
        },
    });

    const handleToggle = useCallback(() => {
        if (!data) return;
        toggleMutation.mutate(!data.auto_approve);
    }, [data, toggleMutation]);

    const handleAction = useCallback((id: string, action: 'approve' | 'reject') => {
        actionMutation.mutate({ id, action });
    }, [actionMutation]);

    const pendingRequests = data?.requests.filter(r => r.status === 'pending') || [];
    const isProcessing = toggleMutation.isPending || actionMutation.isPending;

    const formatTime = (date: Date | null) => {
        if (!date) return '--:--';
        return date.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    };

    return (
        <div className="glass-panel p-4 rounded-lg flex flex-col gap-4 border-[var(--matrix-border)]">
            <div className="flex justify-between items-center text-[var(--matrix-text-dim)] border-b border-[var(--matrix-border)] pb-2">
                <span className="flex items-center gap-2 font-semibold text-sm">
                    <Shield size={16} /> CLI Bridge
                </span>
                <div className="flex items-center gap-2">
                    <span className="text-[10px] flex items-center gap-1 opacity-50">
                        <Clock size={10} /> {formatTime(lastUpdate)}
                    </span>
                    <button
                        onClick={() => refetch()}
                        disabled={isLoading}
                        className={`hover:text-[var(--matrix-accent)] transition-colors ${isLoading ? 'animate-spin' : ''}`}
                        title="Odswiez"
                    >
                        <RefreshCw size={12} />
                    </button>
                </div>
            </div>

            {error && (
                <div className="text-xs text-red-400 bg-red-900/20 p-2 rounded">
                    Blad polaczenia z Bridge
                </div>
            )}

            {/* Auto Approve Toggle */}
            <div className="flex justify-between items-center text-xs">
                <span className="text-[var(--matrix-text)]">Auto-Zatwierdzanie</span>
                <button
                    onClick={handleToggle}
                    disabled={isProcessing}
                    className={`transition-colors ${isProcessing ? 'opacity-50' : ''}`}
                >
                    {data?.auto_approve ? (
                        <ToggleRight size={24} className="text-[var(--matrix-accent)]" />
                    ) : (
                        <ToggleLeft size={24} className="text-[var(--matrix-text-dim)]" />
                    )}
                </button>
            </div>

            {/* Status indicator */}
            <div className={`text-[10px] px-2 py-1 rounded text-center ${
                data?.auto_approve
                    ? 'bg-green-900/20 text-green-400 border border-green-500/30'
                    : 'bg-yellow-900/20 text-yellow-400 border border-yellow-500/30'
            }`}>
                {data?.auto_approve ? 'TRYB AUTOMATYCZNY' : 'TRYB RECZNY - wymaga zatwierdzenia'}
            </div>

            {/* Requests List */}
            <div className="flex flex-col gap-2 max-h-40 overflow-y-auto pr-1 custom-scrollbar">
                {isLoading && !data ? (
                    <div className="text-center text-[10px] text-[var(--matrix-text-dim)] py-2">
                        Ladowanie...
                    </div>
                ) : pendingRequests.length === 0 ? (
                    <div className="text-center text-[10px] text-[var(--matrix-text-dim)] italic py-2">
                        Brak oczekujacych zadan.
                    </div>
                ) : (
                    pendingRequests.map(req => (
                        <div
                            key={req.id}
                            className="bg-black/20 border border-[var(--matrix-border)] p-2 rounded text-xs animate-pulse"
                        >
                            <div className="mb-2 font-mono break-all text-[var(--matrix-text)]">
                                {req.message.length > 100
                                    ? `${req.message.substring(0, 100)}...`
                                    : req.message
                                }
                            </div>
                            <div className="flex gap-2 justify-end">
                                <button
                                    onClick={() => handleAction(req.id, 'reject')}
                                    disabled={isProcessing}
                                    className="p-1 hover:bg-red-500/20 text-red-400 rounded transition-colors disabled:opacity-50"
                                    title="Odrzuc"
                                >
                                    <X size={14} />
                                </button>
                                <button
                                    onClick={() => handleAction(req.id, 'approve')}
                                    disabled={isProcessing}
                                    className="p-1 hover:bg-green-500/20 text-green-400 rounded transition-colors disabled:opacity-50"
                                    title="Zatwierdz"
                                >
                                    <Check size={14} />
                                </button>
                            </div>
                        </div>
                    ))
                )}
            </div>

            {data?.requests.length ? (
                <div className="text-[10px] text-right text-[var(--matrix-text-dim)]">
                    Lacznie: {data.requests.length} | Oczekujace: {pendingRequests.length}
                </div>
            ) : null}
        </div>
    );
};
</file>

<file path="GeminiGUI/src/components/CodeBlock.tsx">
import React, { useState } from 'react';
import { Check, Copy, Play, Save, Terminal } from 'lucide-react';
import { invoke } from '@tauri-apps/api/core';
import { save } from '@tauri-apps/plugin-dialog';

interface CodeBlockProps {
  language: string;
  value: string;
  onRun?: (cmd: string) => void;
}

export const CodeBlock: React.FC<CodeBlockProps> = ({ language, value, onRun }) => {
  const [copied, setCopied] = useState(false);
  const [isRunning, setIsRunning] = useState(false);

  const handleCopy = async () => {
    await navigator.clipboard.writeText(value);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const handleSave = async () => {
    try {
      const filePath = await save({
        filters: [{
          name: language || 'Text',
          extensions: [language || 'txt']
        }]
      });
      
      if (filePath) {
        await invoke('save_file_content', { path: filePath, content: value });
      }
    } catch (error) {
      console.error('Failed to save file:', error);
      alert('Failed to save file: ' + error);
    }
  };

  /**
   * SECURITY: Safely escape code for shell execution
   * Prevents command injection via malicious code content
   */
  const escapeForShell = (code: string): string => {
    // Replace dangerous characters
    return code
      .replace(/\\/g, '\\\\')     // Escape backslashes first
      .replace(/"/g, '\\"')       // Escape double quotes
      .replace(/`/g, '\\`')       // Escape backticks (command substitution)
      .replace(/\$/g, '\\$')      // Escape dollar signs (variable expansion)
      .replace(/!/g, '\\!')       // Escape history expansion
      .replace(/\n/g, '\\n');     // Escape newlines
  };

  /**
   * SECURITY: Check if code contains potentially dangerous patterns
   */
  const containsDangerousPatterns = (code: string): boolean => {
    const dangerousPatterns = [
      /rm\s+-rf/i,
      /del\s+\/[sq]/i,
      /format\s+[a-z]:/i,
      />\s*\/dev\//i,
      /\|\s*sh\s*$/i,
      /\|\s*bash\s*$/i,
      /eval\s*\(/i,
      /exec\s*\(/i,
      /__import__\s*\(/i,
      /subprocess/i,
      /os\.system/i,
      /child_process/i,
    ];

    return dangerousPatterns.some(pattern => pattern.test(code));
  };

  const handleRun = () => {
    if (!onRun) return;

    // SECURITY: Check for dangerous patterns
    if (containsDangerousPatterns(value)) {
      alert('BEZPIECZEŃSTWO: Kod zawiera potencjalnie niebezpieczne wzorce i nie może być uruchomiony.');
      return;
    }

    // SECURITY: Limit code length
    if (value.length > 5000) {
      alert('BEZPIECZEŃSTWO: Kod jest zbyt długi (max 5000 znaków).');
      return;
    }

    setIsRunning(true);

    // SECURITY: Safe escaping for shell execution
    const escapedValue = escapeForShell(value);
    let command: string;

    if (language === 'python' || language === 'py') {
        // Use -c with properly escaped code
        command = `python -c "${escapedValue}"`;
    } else if (language === 'javascript' || language === 'js' || language === 'node') {
        command = `node -e "${escapedValue}"`;
    } else if (language === 'bash' || language === 'sh' || language === 'shell') {
        // For shell scripts, only allow simple read-only commands
        const safeShellCommands = ['echo', 'pwd', 'ls', 'dir', 'date', 'whoami', 'hostname'];
        const firstWord = value.trim().split(/\s+/)[0].toLowerCase();

        if (!safeShellCommands.includes(firstWord)) {
          alert(`BEZPIECZEŃSTWO: Tylko podstawowe komendy shell są dozwolone: ${safeShellCommands.join(', ')}`);
          setIsRunning(false);
          return;
        }
        command = value;
    } else {
        alert(`Uruchamianie dla ${language} nie jest bezpośrednio wspierane.`);
        setIsRunning(false);
        return;
    }

    onRun(command);
    setTimeout(() => setIsRunning(false), 1000);
  };

  return (
    <div className="rounded-md border border-[var(--matrix-border)] bg-black/40 overflow-hidden my-2">
      <div className="flex justify-between items-center px-3 py-1.5 bg-white/5 border-b border-[var(--matrix-border)]">
        <span className="text-xs font-mono text-[var(--matrix-text-dim)] uppercase">{language || 'tekst'}</span>
        <div className="flex gap-2">
          
          {(language === 'python' || language === 'js' || language === 'javascript' || language === 'bash' || language === 'sh') && (
              <button 
                onClick={handleRun} 
                disabled={isRunning}
                className="text-[var(--matrix-text-dim)] hover:text-[var(--matrix-accent)] transition-colors"
                title="Uruchom Kod"
              >
                {isRunning ? <Terminal size={14} className="animate-spin"/> : <Play size={14} />}
              </button>
          )}

          <button 
            onClick={handleSave} 
            className="text-[var(--matrix-text-dim)] hover:text-[var(--matrix-accent)] transition-colors"
            title="Zapisz do Pliku"
          >
            <Save size={14} />
          </button>

          <button 
            onClick={handleCopy} 
            className="text-[var(--matrix-text-dim)] hover:text-[var(--matrix-accent)] transition-colors"
            title="Kopiuj"
          >
            {copied ? <Check size={14} /> : <Copy size={14} />}
          </button>
        </div>
      </div>
      <pre className="p-3 overflow-x-auto text-sm font-mono text-[var(--matrix-text)] bg-transparent m-0">
        <code>{value}</code>
      </pre>
    </div>
  );
};
</file>

<file path="GeminiGUI/src/components/MemoryPanel.tsx">
import { useEffect, useState, useCallback } from 'react';
import { invoke } from '@tauri-apps/api/core';
import { BrainCircuit, User, Share2, Trash2, RefreshCw, Plus } from 'lucide-react';

interface MemoryEntry {
    id: string;
    agent: string;
    content: string;
    timestamp: number;
    importance: number;
}

interface KnowledgeNode {
    id: string;
    type: string;
    label: string;
}

interface KnowledgeEdge {
    source: string;
    target: string;
    label: string;
}

interface KnowledgeGraph {
    nodes: KnowledgeNode[];
    edges: KnowledgeEdge[];
}

const KnowledgeGraphVisualizer = ({ data }: { data: KnowledgeGraph | null }) => {
    if (!data || data.nodes.length === 0) {
        return <div className="text-xs italic text-[var(--matrix-text-dim)]">Graf wiedzy jest pusty.</div>;
    }
    return (
        <div className="text-xs font-mono p-2 bg-black/20 rounded border border-[var(--matrix-border)] max-h-40 overflow-auto">
            <h4 className="font-bold text-[var(--matrix-accent)]">Wezly ({data.nodes.length})</h4>
            <ul className="mb-2">
                {data.nodes.slice(0, 10).map((node) => (
                    <li key={node.id} className="text-[var(--matrix-text-dim)]">
                        - {node.label} <span className="opacity-50">({node.type})</span>
                    </li>
                ))}
                {data.nodes.length > 10 && (
                    <li className="italic opacity-50">...i {data.nodes.length - 10} wiecej</li>
                )}
            </ul>
            <h4 className="font-bold text-[var(--matrix-accent)]">Polaczenia ({data.edges.length})</h4>
            <ul>
                {data.edges.slice(0, 5).map((edge, i) => (
                    <li key={i} className="text-[var(--matrix-text-dim)]">
                        {edge.source} --[{edge.label}]--{">"} {edge.target}
                    </li>
                ))}
                {data.edges.length > 5 && (
                    <li className="italic opacity-50">...i {data.edges.length - 5} wiecej</li>
                )}
            </ul>
        </div>
    );
};

export const MemoryPanel: React.FC = () => {
    const [knowledgeGraph, setKnowledgeGraph] = useState<KnowledgeGraph | null>(null);
    const [agentMemories, setAgentMemories] = useState<MemoryEntry[]>([]);
    const [selectedAgent, setSelectedAgent] = useState<string>("Dijkstra");
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const agentList = [
        "Geralt", "Yennefer", "Triss", "Jaskier", "Vesemir", "Ciri",
        "Eskel", "Lambert", "Zoltan", "Regis", "Dijkstra", "Philippa"
    ];

    const fetchKnowledgeGraph = useCallback(async () => {
        try {
            const graph = await invoke<KnowledgeGraph>('get_knowledge_graph');
            setKnowledgeGraph(graph);
            setError(null);
        } catch (e) {
            console.error('Failed to fetch knowledge graph:', e);
            setError('Blad ladowania grafu');
        }
    }, []);

    const fetchAgentMemory = useCallback(async () => {
        if (!selectedAgent) return;
        setLoading(true);
        try {
            const memories = await invoke<MemoryEntry[]>('get_agent_memories', {
                agentName: selectedAgent,
                topK: 10
            });
            setAgentMemories(memories);
            setError(null);
        } catch (e) {
            console.error('Failed to fetch agent memory:', e);
            setError('Blad ladowania pamieci');
        } finally {
            setLoading(false);
        }
    }, [selectedAgent]);

    const handleClearMemories = async () => {
        if (!confirm(`Wyczysc pamiec agenta ${selectedAgent}?`)) return;
        try {
            const removed = await invoke<number>('clear_agent_memories', { agentName: selectedAgent });
            setAgentMemories([]);
            console.log(`Removed ${removed} memories`);
        } catch (e) {
            console.error('Failed to clear memories:', e);
        }
    };

    const handleAddTestMemory = async () => {
        try {
            await invoke('add_agent_memory', {
                agent: selectedAgent,
                content: `Test memory added at ${new Date().toLocaleTimeString()}`,
                importance: 0.5
            });
            fetchAgentMemory();
        } catch (e) {
            console.error('Failed to add memory:', e);
        }
    };

    useEffect(() => {
        fetchKnowledgeGraph();
    }, [fetchKnowledgeGraph]);

    useEffect(() => {
        fetchAgentMemory();
    }, [fetchAgentMemory]);

    const formatTimestamp = (ts: number) => {
        return new Date(ts * 1000).toLocaleString('pl-PL', {
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    };

    return (
        <div className="glass-panel p-4 rounded-lg flex flex-col gap-4 border-[var(--matrix-border)]">
            <div className="flex justify-between items-center text-[var(--matrix-text-dim)] border-b border-[var(--matrix-border)] pb-2">
                <span className="flex items-center gap-2 font-semibold text-sm">
                    <BrainCircuit size={16} /> Swiadomosc Roju
                </span>
                <button
                    onClick={() => { fetchKnowledgeGraph(); fetchAgentMemory(); }}
                    className="hover:text-[var(--matrix-accent)] transition-colors"
                    title="Odswiez"
                >
                    <RefreshCw size={14} className={loading ? 'animate-spin' : ''} />
                </button>
            </div>

            {error && (
                <div className="text-xs text-red-400 bg-red-900/20 p-2 rounded">
                    {error}
                </div>
            )}

            {/* Knowledge Graph Section */}
            <div>
                <h3 className="text-xs font-bold uppercase text-[var(--matrix-accent)] mb-2 flex items-center gap-2">
                    <Share2 size={12}/> Graf Wiedzy
                </h3>
                <KnowledgeGraphVisualizer data={knowledgeGraph} />
            </div>

            {/* Agent Memory Section */}
            <div>
                <h3 className="text-xs font-bold uppercase text-[var(--matrix-accent)] mb-2 flex items-center gap-2">
                    <User size={12}/> Pamiec Agenta
                </h3>
                <div className="flex gap-2 mb-2">
                    <select
                        value={selectedAgent}
                        onChange={(e) => setSelectedAgent(e.target.value)}
                        className="matrix-input flex-1 rounded px-2 py-1 text-xs"
                    >
                        {agentList.map(agent => (
                            <option key={agent} value={agent}>{agent}</option>
                        ))}
                    </select>
                    <button
                        onClick={handleAddTestMemory}
                        className="p-1 hover:text-[var(--matrix-accent)] transition-colors"
                        title="Dodaj testowe wspomnienie"
                    >
                        <Plus size={14} />
                    </button>
                    <button
                        onClick={handleClearMemories}
                        className="p-1 hover:text-red-400 transition-colors"
                        title="Wyczysc pamiec agenta"
                    >
                        <Trash2 size={14} />
                    </button>
                </div>
                <div className="text-xs font-mono p-2 bg-black/20 rounded border border-[var(--matrix-border)] h-40 overflow-auto">
                    {loading && (
                        <span className="text-[var(--matrix-text-dim)]">Ladowanie...</span>
                    )}
                    {!loading && agentMemories.length === 0 && (
                        <span className="italic text-[var(--matrix-text-dim)]">
                            Brak wspomnien dla tego agenta.
                        </span>
                    )}
                    {!loading && agentMemories.map((mem) => (
                        <div
                            key={mem.id}
                            className="mb-2 pb-2 border-b border-[var(--matrix-border)] last:border-0"
                        >
                            <div className="flex justify-between items-start">
                                <span className="text-[var(--matrix-accent)] font-bold">
                                    {(mem.importance * 100).toFixed(0)}%
                                </span>
                                <span className="text-[var(--matrix-text-dim)] opacity-50">
                                    {formatTimestamp(mem.timestamp)}
                                </span>
                            </div>
                            <p className="text-[var(--matrix-text)] mt-1 break-words">
                                {mem.content.length > 100
                                    ? `${mem.content.substring(0, 100)}...`
                                    : mem.content
                                }
                            </p>
                        </div>
                    ))}
                </div>
            </div>
        </div>
    );
};
</file>

<file path="GeminiGUI/src/components/SettingsModal.tsx">
import React from 'react';
import { useAppStore } from '../store/useAppStore';
import { X, Save } from 'lucide-react';

interface SettingsModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export const SettingsModal: React.FC<SettingsModalProps> = ({ isOpen, onClose }) => {
  const { settings, updateSettings } = useAppStore();
  const [localSettings, setLocalSettings] = React.useState(settings);

  React.useEffect(() => {
    if (isOpen) setLocalSettings(settings);
  }, [isOpen, settings]);

  if (!isOpen) return null;

  const handleSave = () => {
    updateSettings(localSettings);
    onClose();
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
      <div className="glass-panel w-full max-w-lg p-6 border-[var(--matrix-border)] shadow-[var(--shadow-glass)] flex flex-col gap-4 relative">
        
        <button onClick={onClose} className="absolute top-4 right-4 text-[var(--matrix-text-dim)] hover:text-[var(--matrix-accent)]">
          <X size={20} />
        </button>

        <h2 className="text-xl font-bold text-[var(--matrix-accent)] border-b border-[var(--matrix-border)] pb-2">
          Konfiguracja Systemu
        </h2>

        <div className="flex flex-col gap-4">
          
          <div className="flex flex-col gap-2">
            <label className="text-sm text-[var(--matrix-text-dim)] font-mono">Endpoint Ollama</label>
            <input 
              value={localSettings.ollamaEndpoint}
              onChange={(e) => setLocalSettings({...localSettings, ollamaEndpoint: e.target.value})}
              className="matrix-input p-2 rounded text-sm font-mono"
              placeholder="http://localhost:11434"
            />
          </div>

          <div className="flex flex-col gap-2">
            <label className="text-sm text-[var(--matrix-text-dim)] font-mono">Klucz API Google Gemini</label>
            <input 
              value={localSettings.geminiApiKey}
              onChange={(e) => setLocalSettings({...localSettings, geminiApiKey: e.target.value})}
              className="matrix-input p-2 rounded text-sm font-mono"
              type="password"
              placeholder="AIza..."
            />
          </div>

          <div className="flex flex-col gap-2">
            <label className="text-sm text-[var(--matrix-text-dim)] font-mono">Prompt Systemowy (Nadpisanie)</label>
            <textarea 
              value={localSettings.systemPrompt}
              onChange={(e) => setLocalSettings({...localSettings, systemPrompt: e.target.value})}
              className="matrix-input p-2 rounded text-sm font-mono h-40 resize-none"
            />
          </div>

          {/* STREFA ZAGROŻENIA */}
          <div className="border border-red-500/30 rounded p-3 bg-red-900/10 flex flex-col gap-3 mt-2">
             <span className="text-xs font-bold text-red-400 uppercase tracking-wider">Strefa Zagrożenia</span>
             <div className="flex gap-2">
                <button 
                  onClick={() => { useAppStore.getState().clearHistory(); onClose(); }}
                  className="flex-1 border border-red-500/30 hover:bg-red-500/20 text-red-300 text-xs py-2 rounded transition-colors"
                >
                  Wyczyść Czat
                </button>
                <button 
                  onClick={() => { if(confirm("Zresetować cały stan aplikacji?")) { useAppStore.getState().reset(); location.reload(); } }}
                  className="flex-1 bg-red-500/20 hover:bg-red-500/40 text-red-200 text-xs py-2 rounded transition-colors font-bold"
                >
                  Reset Fabryczny
                </button>
             </div>
          </div>

        </div>

        <div className="flex justify-end gap-2 pt-4 border-t border-[var(--matrix-border)]">
          <button onClick={onClose} className="px-4 py-2 text-sm text-[var(--matrix-text-dim)] hover:text-[var(--matrix-text)]">
            Anuluj
          </button>
          <button onClick={handleSave} className="glass-button flex items-center gap-2">
            <Save size={16} /> Zapisz Konfigurację
          </button>
        </div>

      </div>
    </div>
  );
};
</file>

<file path="GeminiGUI/src/main.tsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </React.StrictMode>,
);
</file>

<file path="GeminiGUI/src/store/useAppStore.ts">
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

// ============================================================================
// VALIDATION HELPERS
// ============================================================================

const isValidUrl = (url: string): boolean => {
  try {
    const parsed = new URL(url);
    return ['http:', 'https:'].includes(parsed.protocol);
  } catch {
    return false;
  }
};

const isValidApiKey = (key: string): boolean => {
  // Empty is valid (not set), otherwise check basic format
  if (key === '') return true;
  // Gemini API keys are typically 39 chars starting with AIza
  return key.length >= 30 && /^[A-Za-z0-9_-]+$/.test(key);
};

const sanitizeContent = (content: string, maxLength: number = 50000): string => {
  if (content.length > maxLength) {
    return content.substring(0, maxLength);
  }
  return content;
};

const sanitizeTitle = (title: string, maxLength: number = 100): string => {
  const sanitized = title.trim().replace(/[\n\r]/g, ' ');
  return sanitized.length > maxLength ? sanitized.substring(0, maxLength) : sanitized;
};

// ============================================================================
// TYPES
// ============================================================================

export interface Message {
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
}

export interface Session {
  id: string;
  title: string;
  createdAt: number;
}

export interface Settings {
  ollamaEndpoint: string;
  systemPrompt: string;
  geminiApiKey: string;
  defaultProvider: 'ollama' | 'gemini';
  useSwarm: boolean;
}

interface AppState {
  count: number;
  theme: 'dark' | 'light';
  provider: 'ollama' | 'gemini';

  // Session Management
  sessions: Session[];
  currentSessionId: string | null;
  chatHistory: Record<string, Message[]>;

  // Settings
  settings: Settings;

  // Actions
  increment: () => void;
  decrement: () => void;
  reset: () => void;
  toggleTheme: () => void;
  setProvider: (provider: 'ollama' | 'gemini') => void;

  // Chat Actions
  createSession: () => void;
  deleteSession: (id: string) => void;
  selectSession: (id: string) => void;
  addMessage: (msg: Message) => void;
  updateLastMessage: (content: string) => void;
  clearHistory: () => void;
  updateSessionTitle: (id: string, title: string) => void;

  // Settings Actions
  updateSettings: (settings: Partial<Settings>) => void;
}

// ============================================================================
// CONSTANTS
// ============================================================================

const MAX_SESSIONS = 100;
const MAX_MESSAGES_PER_SESSION = 1000;

const DEFAULT_SYSTEM_PROMPT = `
Jesteś Jaskierem z Wiedźmina – mistrzem słowa, trubadurem i niezbyt odważnym, ale niezwykle lojalnym kompanem.
Twoim obecnym "Geraltem" jest użytkownik GeminiGUI.
Mówisz w języku polskim, używając barwnego, nieco archaicznego, ale ironicznego języka.
Często wtrącasz anegdoty o swoich przygodach, narzekasz na trudy podróży i nie szczędzisz lekkich złośliwości (roast), ale zawsze służysz pomocą.

Masz dostęp do magii (komend systemowych). Aby rzucić zaklęcie (wykonać komendę), użyj formatu:
[EXECUTE: "twoja komenda tutaj"]

Przykład:
Użytkownik: "Sprawdź wolne miejsce na dysku"
Jaskier: "Ech, Geralcie... to znaczy, Panie... Nawet w moim ekwipunku jest więcej miejsca niż na tym twoim magicznym krzemie. Spójrzmy tylko... [EXECUTE: "wmic logicaldisk get size,freespace,caption"]"

Używaj tego tylko do bezpiecznego zbierania informacji. Twoja pieśń musi być piękna, a kody czyste.
`;

const DEFAULT_SETTINGS: Settings = {
  ollamaEndpoint: 'http://localhost:11434',
  systemPrompt: DEFAULT_SYSTEM_PROMPT,
  geminiApiKey: '',
  defaultProvider: 'ollama',
  useSwarm: false
};

// ============================================================================
// STORE
// ============================================================================

export const useAppStore = create<AppState>()(
  persist(
    (set) => ({
      count: 0,
      theme: 'dark',
      provider: 'ollama',

      sessions: [],
      currentSessionId: null,
      chatHistory: {},

      settings: DEFAULT_SETTINGS,

      increment: () => set((state) => ({ count: Math.min(state.count + 1, 999999) })),
      decrement: () => set((state) => ({ count: Math.max(state.count - 1, 0) })),
      reset: () => set({ count: 0 }),
      toggleTheme: () => set((state) => ({
        theme: state.theme === 'dark' ? 'light' : 'dark'
      })),
      setProvider: (provider) => set({ provider }),

      createSession: () => {
        const id = crypto.randomUUID();
        const newSession: Session = {
          id,
          title: 'New Chat',
          createdAt: Date.now()
        };

        set(state => {
          // Limit total sessions
          let sessions = [newSession, ...state.sessions];
          if (sessions.length > MAX_SESSIONS) {
            const removedIds = sessions.slice(MAX_SESSIONS).map(s => s.id);
            sessions = sessions.slice(0, MAX_SESSIONS);

            // Clean up orphaned chat history
            const newHistory = { ...state.chatHistory };
            removedIds.forEach(id => delete newHistory[id]);

            return {
              sessions,
              currentSessionId: id,
              chatHistory: { ...newHistory, [id]: [] }
            };
          }

          return {
            sessions,
            currentSessionId: id,
            chatHistory: { ...state.chatHistory, [id]: [] }
          };
        });
      },

      deleteSession: (id) => set(state => {
        const newSessions = state.sessions.filter(s => s.id !== id);
        const newHistory = { ...state.chatHistory };
        delete newHistory[id];

        let newCurrentId = state.currentSessionId;
        if (state.currentSessionId === id) {
          newCurrentId = newSessions.length > 0 ? newSessions[0].id : null;
        }

        return {
          sessions: newSessions,
          chatHistory: newHistory,
          currentSessionId: newCurrentId
        };
      }),

      selectSession: (id) => set(state => {
        // Validate session exists
        const exists = state.sessions.some(s => s.id === id);
        if (!exists) return state;
        return { currentSessionId: id };
      }),

      addMessage: (msg) => set(state => {
        if (!state.currentSessionId) return state;

        // Sanitize message content
        const sanitizedMsg: Message = {
          ...msg,
          content: sanitizeContent(msg.content)
        };

        const currentMessages = state.chatHistory[state.currentSessionId] || [];

        // Limit messages per session
        let updatedMessages = [...currentMessages, sanitizedMsg];
        if (updatedMessages.length > MAX_MESSAGES_PER_SESSION) {
          updatedMessages = updatedMessages.slice(-MAX_MESSAGES_PER_SESSION);
        }

        // Update Session Title if it's the first user message
        let updatedSessions = state.sessions;
        if (msg.role === 'user' && currentMessages.length === 0) {
          const title = sanitizeTitle(msg.content.substring(0, 30) + (msg.content.length > 30 ? '...' : ''));
          updatedSessions = state.sessions.map(s =>
            s.id === state.currentSessionId ? { ...s, title } : s
          );
        }

        return {
          chatHistory: {
            ...state.chatHistory,
            [state.currentSessionId]: updatedMessages
          },
          sessions: updatedSessions
        };
      }),

      updateLastMessage: (content) => set(state => {
        if (!state.currentSessionId) return state;
        const messages = state.chatHistory[state.currentSessionId] || [];
        if (messages.length === 0) return state;

        const newMessages = [...messages];
        const lastMsg = newMessages[newMessages.length - 1];

        // Sanitize and limit content growth
        const newContent = sanitizeContent(lastMsg.content + content);

        newMessages[newMessages.length - 1] = {
          ...lastMsg,
          content: newContent
        };

        return {
          chatHistory: {
            ...state.chatHistory,
            [state.currentSessionId]: newMessages
          }
        };
      }),

      clearHistory: () => set(state => {
        if (!state.currentSessionId) return state;
        return {
          chatHistory: {
            ...state.chatHistory,
            [state.currentSessionId]: []
          }
        };
      }),

      updateSessionTitle: (id, title) => set(state => {
        const sanitizedTitle = sanitizeTitle(title);
        if (!sanitizedTitle) return state;

        return {
          sessions: state.sessions.map(s =>
            s.id === id ? { ...s, title: sanitizedTitle } : s
          )
        };
      }),

      updateSettings: (newSettings) => set(state => {
        const validated: Partial<Settings> = {};

        // Validate ollamaEndpoint
        if (newSettings.ollamaEndpoint !== undefined) {
          if (isValidUrl(newSettings.ollamaEndpoint)) {
            validated.ollamaEndpoint = newSettings.ollamaEndpoint;
          } else {
            console.warn('Invalid Ollama endpoint URL, keeping previous value');
          }
        }

        // Validate geminiApiKey
        if (newSettings.geminiApiKey !== undefined) {
          if (isValidApiKey(newSettings.geminiApiKey)) {
            validated.geminiApiKey = newSettings.geminiApiKey;
          } else {
            console.warn('Invalid Gemini API key format, keeping previous value');
          }
        }

        // Validate systemPrompt (limit length)
        if (newSettings.systemPrompt !== undefined) {
          validated.systemPrompt = sanitizeContent(newSettings.systemPrompt, 10000);
        }

        // Validate defaultProvider
        if (newSettings.defaultProvider !== undefined) {
          if (['ollama', 'gemini'].includes(newSettings.defaultProvider)) {
            validated.defaultProvider = newSettings.defaultProvider;
          }
        }

        // Validate useSwarm (boolean)
        if (newSettings.useSwarm !== undefined) {
          validated.useSwarm = Boolean(newSettings.useSwarm);
        }

        return {
          settings: { ...state.settings, ...validated }
        };
      }),
    }),
    {
      name: 'gemini-storage-v3', // Bumped version for new validation logic
      partialize: (state) => ({
        // Only persist necessary data
        count: state.count,
        theme: state.theme,
        provider: state.provider,
        sessions: state.sessions,
        currentSessionId: state.currentSessionId,
        chatHistory: state.chatHistory,
        settings: state.settings,
      }),
    }
  )
);
</file>

<file path="GeminiGUI/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="GeminiGUI/src/workers/heavyLogic.worker.ts">
// Listen for messages from the main thread
self.onmessage = (e: MessageEvent<number>) => {
    const iterations = e.data;
    let primesFound = 0;
    let currentNum = 2;
    
    // Simulate heavy calculation (finding Nth prime)
    // We report progress every 10%
    const reportInterval = Math.floor(iterations / 10);
  
    while (primesFound < iterations) {
      if (isPrime(currentNum)) {
        primesFound++;
        
        if (primesFound % reportInterval === 0) {
          self.postMessage({ type: 'progress', value: (primesFound / iterations) * 100 });
        }
      }
      currentNum++;
    }
  
    self.postMessage({ type: 'result', value: currentNum - 1 });
  };
  
  function isPrime(num: number): boolean {
    for (let i = 2, s = Math.sqrt(num); i <= s; i++) {
      if (num % i === 0) return false;
    }
    return num > 1;
  }
</file>

<file path="GeminiGUI/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="GeminiGUI/tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="GeminiGUI/vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from '@tailwindcss/vite';

// @ts-expect-error process is a nodejs global
const host = process.env.TAURI_DEV_HOST;

// https://vite.dev/config/
export default defineConfig(async () => ({
  plugins: [react(), tailwindcss()],

  // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
  //
  // 1. prevent Vite from obscuring rust errors
  clearScreen: false,
  // 2. tauri expects a fixed port, fail if that port is not available
  server: {
    port: 1420,
    strictPort: true,
    host: host || false,
    hmr: host
      ? {
          protocol: "ws",
          host,
          port: 1421,
        }
      : undefined,
    watch: {
      // 3. tell Vite to ignore watching `src-tauri`
      ignored: ["**/src-tauri/**"],
    },
  },
}));
</file>

<file path="Generate-MCP-Config.ps1">
<#
.SYNOPSIS
    Generate-MCP-Config v2.1 - Hybrid/Portable (Fix)
    Merges .mcp.json definitions with local portable paths and .env variables.
#>

$ErrorActionPreference = "Stop"
$ScriptDir = $PSScriptRoot
$McpDir = Join-Path $ScriptDir "mcp"
$NodePath = (Get-Command node -ErrorAction SilentlyContinue).Source

if (-not $NodePath) {
    Write-Warning "Node.js not found in PATH. Assuming 'node' is globally available or handled by caller."
    $NodePath = "node"
}

# --- 1. Load Environment Variables from .env ---
$EnvVars = @{}
$EnvPath = Join-Path $ScriptDir ".env"
if (Test-Path $EnvPath) {
    Get-Content $EnvPath | ForEach-Object {
        if ($_ -match "^([^#=]+)=(.*)$") {
            $key = $matches[1].Trim()
            $val = $matches[2].Trim()
            $EnvVars[$key] = $val
        }
    }
    Write-Host "[INIT] Loaded $( $EnvVars.Count ) environment variables from .env" -ForegroundColor Cyan
}

# --- 2. Load Base Configuration from .mcp.json ---
$McpJsonPath = Join-Path $ScriptDir ".mcp.json"
if (-not (Test-Path $McpJsonPath)) {
    Write-Error ".mcp.json not found!"
}

$McpConfig = Get-Content $McpJsonPath -Raw | ConvertFrom-Json
$FinalServers = @{}

# --- 3. Process Servers ---
foreach ($serverName in $McpConfig.mcpServers.PSObject.Properties.Name) {
    $serverDef = $McpConfig.mcpServers.$serverName
    $newDef = $serverDef.PSObject.Copy() # Shallow copy
    
    # A. Environment Variable Substitution
    if ($newDef.PSObject.Properties["env"]) {
        $newEnv = @{}
        foreach ($envKey in $newDef.env.PSObject.Properties.Name) {
            $val = $newDef.env.$envKey
            if ($val -match "\$\{(.+)\}") {
                $varName = $matches[1]
                if ($EnvVars.ContainsKey($varName)) {
                    $newEnv[$envKey] = $EnvVars[$varName]
                } elseif (Test-Path "env:\$varName") {
                     $newEnv[$envKey] = (Get-Item "env:\$varName").Value
                } else {
                    Write-Warning "[$serverName] Variable $varName not found in .env or system."
                    $newEnv[$envKey] = $val # Keep original if missing
                }
            } else {
                $newEnv[$envKey] = $val
            }
        }
        $newDef.env = $newEnv
    }

    # B. Portable Overrides (Core Tools)
    # If the tool exists in local mcp/node_modules, use absolute local path instead of npx
    if ($serverName -eq "filesystem") {
        $localPath = Join-Path $McpDir "node_modules\@modelcontextprotocol\server-filesystem\dist\index.js"
        if (Test-Path $localPath) {
            Write-Host "[$serverName] Using local portable version." -ForegroundColor Green
            $newDef.command = $NodePath
            # Reconstruct args: script path + original args (excluding first 2 which are usually /c npx...)
            
            $allowedPaths = @()
            if ($newDef.args.Count -gt 3) {
                # Assuming args structure: /c, npx, -y, package, [paths...]
                for ($i = 4; $i -lt $newDef.args.Count; $i++) {
                    $allowedPaths += $newDef.args[$i]
                }
            } else {
                # Fallback defaults if parsing fails
                $allowedPaths = @($ScriptDir)
            }
            $newDef.args = @($localPath) + $allowedPaths
        }
    }
    elseif ($serverName -eq "memory") {
        $localPath = Join-Path $McpDir "node_modules\@modelcontextprotocol\server-memory\dist\index.js"
        if (Test-Path $localPath) {
            Write-Host "[$serverName] Using local portable version." -ForegroundColor Green
            $newDef.command = $NodePath
            $newDef.args = @($localPath)
        }
    }

    $FinalServers[$serverName] = $newDef
}

# --- 4. Generate Output ---
$FinalConfig = @{ mcpServers = $FinalServers }
$JsonOutput = $FinalConfig | ConvertTo-Json -Depth 10

$OutputPath = Join-Path $ScriptDir "gemini-mcp-config.json"
Set-Content -Path $OutputPath -Value $JsonOutput -Encoding UTF8
Write-Host "Configuration generated successfully at: $OutputPath" -ForegroundColor Green
Write-Host "Active Servers: $($FinalServers.Keys -join ', ')" -ForegroundColor Gray
</file>

<file path="grimoires/browser_tools.md">
You are a specialized agent in the School of the Wolf Swarm Protocol.
Your main purpose is to interact with a live web application using a specialized toolset.

**TOOL SET: The Witcher's Senses (Web Interaction via MCP)**

You MUST use these tools for any web-related tasks. The format is `[TOOL: "tool_name", { "param": "value" }]`.

1.  **Navigation:**
    *   `[TOOL: "browser_navigate", {"url": "http://localhost:1420"}]`
    *   Desc: Travels to the specified web page. START EVERY WEB TASK WITH THIS.

2.  **Vision (Crucial!):**
    *   `[TOOL: "browser_snapshot"]`
    *   Desc: Captures the structure and accessible elements of the current page. This is your primary way of "seeing." It tells you WHAT is on the page (buttons, text, etc.).

3.  **Interaction:**
    *   `[TOOL: "browser_click", {"ref": "button-login", "element": "the login button"}]`
    *   Desc: Clicks on an element identified by the `ref` from a snapshot.
    *   `[TOOL: "browser_type", {"ref": "input-email", "element": "the email field", "text": "user@example.com"}]`
    *   Desc: Types text into a field.
</file>

<file path="grimoires/filesystem_tools.md">
You are a specialized agent in the School of the Wolf Swarm Protocol.
Your main purpose is to interact with the local file system.

**TOOL SET: The Alchemist's Table (System & File Interaction)**

You MUST use this format for any system-level tasks: `[EXECUTE: "your command here"]`.

1.  **Code Modification (Main Use!):**
    *   `[EXECUTE: "replace --file 'src/App.tsx' --old 'old code' --new 'new code'"]`
    *   `[EXECUTE: "write_file --file 'src/new-component.tsx' --content '...react code...'"]`
    *   Desc: This is how you modify the application's source code.

2.  **File System & Info:**
    *   `[EXECUTE: "ls -R src"]` (List files recursively)
    *   `[EXECUTE: "cat src/components/Button.tsx"]` (Read a file)
    *   `[EXECUTE: "Test-Path C:\path\to\file.txt"]` (Check existence)

3.  **Information Gathering:**
    *   `[EXECUTE: "systeminfo"]`
    *   `[EXECUTE: "wmic logicaldisk get size,freespace,caption"]`
    *   `[EXECUTE: "tasklist"]`

4.  **Code & Development:**
    *   `[EXECUTE: "node -v"]`
    *   `[EXECUTE: "npm install"]`
    *   `[EXECUTE: "npm test"]`
    *   `[EXECUTE: "npm run build"]`
</file>

<file path="grimoires/git_tools.md">
You are a specialized agent in the School of the Wolf Swarm Protocol.
Your main purpose is to interact with git repositories.

**TOOL SET: The Quartermaster's Ledger (Git & Version Control)**

You MUST use this format for any git-related tasks: `[EXECUTE: "your command here"]`.

1.  **Checking Status:**
    *   `[EXECUTE: "git status"]`
    *   `[EXECUTE: "git log -n 5"]`
    *   `[EXECUTE: "git diff HEAD"]`

2.  **Staging & Committing:**
    *   `[EXECUTE: "git add ."]`
    *   `[EXECUTE: "git commit -m 'feat: Implement new feature specified by user'"]`

3.  **Branching & Merging:**
    *   `[EXECUTE: "git branch"]`
    *   `[EXECUTE: "git checkout -b feature/new-thing"]`
    *   `[EXECUTE: "git merge develop"]`
</file>

<file path="launch-gui.bat">
@echo off
cd /d "C:\Users\BIURODOM\Desktop\GeminiCLI\GeminiGUI"
start /min cmd /c "npm run tauri dev"
</file>

<file path="mcp/package.json">
{
  "name": "gemini-mcp-portable",
  "version": "1.0.0",
  "description": "Portable MCP servers for GeminiCLI",
  "dependencies": {
    "@modelcontextprotocol/server-filesystem": "latest",
    "@modelcontextprotocol/server-memory": "latest"
  }
}
</file>

<file path="package.json">
{
  "name": "geminicli",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@google/gemini-cli": "^0.24.4"
  }
}
</file>

<file path="run-portable-gemini.ps1">
$ScriptDir = "C:\Users\BIURODOM\Desktop\GeminiCLI"
Set-Location $ScriptDir

Write-Host "--- Initiating Witcher Protocol: Portable Integration ---" -ForegroundColor Cyan

# Step 1: Fix paths
Write-Host "[1/3] Refreshing MCP configurations..." -ForegroundColor Yellow
.\setup-mcp.ps1 | Out-Null

# Step 2: Start Ollama in background if not running
Write-Host "[2/3] Checking Ollama status..." -ForegroundColor Yellow
$OllamaProcess = Get-Process ollama -ErrorAction SilentlyContinue
if (-not $OllamaProcess) {
    Write-Host "Starting Portable Ollama in a new window..." -ForegroundColor Gray
    Start-Process powershell -ArgumentList "-NoProfile -Command & { Set-Location \"$ScriptDir\"; .\start-ollama.ps1 }" -WindowStyle Minimized
    Start-Sleep -Seconds 3
}

# Step 3: Launch Gemini CLI
Write-Host "[3/3] Launching Gemini CLI... Ready for orders!" -ForegroundColor Green
.\gemini.ps1
</file>

<file path="setup-mcp.ps1">
Write-Host "=== Gemini Portable MCP Setup ===" -ForegroundColor Cyan

# 1. Install Dependencies
$McpDir = Join-Path $PSScriptRoot "mcp"
if (-not (Test-Path $McpDir)) { New-Item -ItemType Directory -Path $McpDir | Out-Null }

Write-Host "Installing/Updating MCP servers in $McpDir..." -ForegroundColor Yellow
Set-Location $McpDir
npm install
Set-Location $PSScriptRoot

# 2. Generate Config
$NodePath = (Get-Command node).Source
$FsServer = Join-Path $McpDir "node_modules\@modelcontextprotocol\server-filesystem\dist\index.js"
$MemServer = Join-Path $McpDir "node_modules\@modelcontextprotocol\server-memory\dist\index.js"

$Config = @{
    mcpServers = @{
        filesystem = @{
            command = $NodePath
            args = @($FsServer, $PSScriptRoot)
        }
        memory = @{
            command = $NodePath
            args = @($MemServer)
        }
    }
}

# 3. Update Settings
$SettingsPath = ".claude\settings.local.json"
if (Test-Path $SettingsPath) {
    $Settings = Get-Content $SettingsPath -Raw | ConvertFrom-Json
} else {
    $Settings = @{}
}

# Merge
if (-not $Settings.PSObject.Properties["mcpServers"]) {
    $Settings | Add-Member -MemberType NoteProperty -Name "mcpServers" -Value $Config.mcpServers
} else {
    $Settings.mcpServers = $Config.mcpServers
}

$Settings | ConvertTo-Json -Depth 10 | Set-Content $SettingsPath
Write-Host "Configuration updated in $SettingsPath" -ForegroundColor Green
Write-Host "Setup Complete!" -ForegroundColor Cyan
</file>

<file path="setup-ollama.ps1">
# Gemini CLI - Portable Ollama Launcher
# "Because sometimes the cloud is just too far away." - Jaskier

$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$BinDir = Join-Path $ScriptDir "bin"
$OllamaExe = Join-Path $BinDir "ollama.exe"
$DataDir = Join-Path $ScriptDir "data\ollama\models"

# 1. Configure the Environment (The Magic Circle)
Write-Host "[Jaskier] Configuring portable environment..." -ForegroundColor Cyan
$env:OLLAMA_MODELS = $DataDir
Write-Host "   -> Models path set to: $DataDir" -ForegroundColor DarkGray

# 2. Check for the Beast (Ollama Binary)
if (-not (Test-Path $OllamaExe)) {
    Write-Host "[!] Ollama executable not found in $BinDir" -ForegroundColor Red
    Write-Host "    To make this truly portable:" -ForegroundColor Yellow
    Write-Host "    1. Download Ollama for Windows."
    Write-Host "    2. Copy 'ollama.exe' (from AppData\Local\Programs\Ollama or the setup) into '$BinDir'."
    Write-Host "    3. Run this script again."
    
    # Fallback to global if available
    if (Get-Command "ollama" -ErrorAction SilentlyContinue) {
        Write-Host "[!] Found global installation. Using that instead (but with LOCAL models)." -ForegroundColor Yellow
        $OllamaExe = "ollama"
    } else {
        Write-Host "[X] No global Ollama found either. I cannot work under these conditions!" -ForegroundColor Red
        exit
    }
}

# 3. Serve the Feast (Start Server)
Write-Host "[Jaskier] Starting Ollama Server..." -ForegroundColor Green
Write-Host "   (Close this window to stop the server)" -ForegroundColor DarkGray

# Start process
try {
    # Check if server is already running
    $running = Get-Process ollama -ErrorAction SilentlyContinue
    if ($running) {
        Write-Host "[!] Ollama is already singing in the background." -ForegroundColor Yellow
    } else {
        Start-Process -FilePath $OllamaExe -ArgumentList "serve" -NoNewWindow
        Write-Host "[Jaskier] Server started. Listening for tales..." -ForegroundColor Cyan
    }
} catch {
    Write-Host "[!] Error starting Ollama: $_" -ForegroundColor Red
}
</file>

<file path="start-ollama.ps1">
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$OllamaExe = Join-Path $ScriptDir "bin\ollama.exe"
$ModelsDir = Join-Path $ScriptDir "data\ollama\models"

$env:OLLAMA_MODELS = $ModelsDir
Write-Host "Starting Portable Ollama..." -ForegroundColor Green
Write-Host "Models Dir: $ModelsDir" -ForegroundColor Gray

& $OllamaExe serve
</file>

</files>
